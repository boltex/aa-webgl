{
  "leoHeader": {
    "fileFormat": 2
  },
  "vnodes": [
    {
      "gnx": "felix.20241113233438.1",
      "vh": "Introduction"
    },
    {
      "gnx": "felix.20241118225416.1",
      "vh": "code",
      "children": [
        {
          "gnx": "felix.20241118225308.1",
          "vh": "Hello World",
          "children": [
            {
              "gnx": "felix.20241118225357.1",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241118225400.1",
              "vh": "main"
            }
          ]
        },
        {
          "gnx": "felix.20241116232514.1",
          "vh": "Chapter3 Uniforms",
          "children": [
            {
              "gnx": "felix.20241113235415.1",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241113235430.1",
              "vh": "main"
            }
          ]
        },
        {
          "gnx": "felix.20241116232737.1",
          "vh": "Chapter4-5 Attributes",
          "children": [
            {
              "gnx": "felix.20241116232737.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241116232737.3",
              "vh": "main"
            }
          ]
        },
        {
          "gnx": "felix.20241117233253.1",
          "vh": "Chapter6 Elements Arrays",
          "children": [
            {
              "gnx": "felix.20241117233253.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241117233253.3",
              "vh": "main"
            }
          ]
        },
        {
          "gnx": "felix.20241118225644.1",
          "vh": "Chapter8 Textures",
          "children": [
            {
              "gnx": "felix.20241118225644.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241124171038.1",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241124171224.1",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241118225644.3",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241126223424.1",
          "vh": "Chapter 10 Vertex Array Objects (Start)",
          "children": [
            {
              "gnx": "felix.20241126223424.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241126223424.3",
              "vh": "main"
            }
          ]
        },
        {
          "gnx": "felix.20241124205404.1",
          "vh": "Chapter 10 Vertex Array Objects (Done)",
          "children": [
            {
              "gnx": "felix.20241124205404.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241124205404.3",
              "vh": "main"
            }
          ]
        },
        {
          "gnx": "felix.20241201235534.1",
          "vh": "Chapter 11 Sprite Sheets",
          "children": [
            {
              "gnx": "felix.20241201235534.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241201235534.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241201235534.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241201235534.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241126234030.1",
          "vh": "Chapter 12 VERTICAL Texture Arrays",
          "children": [
            {
              "gnx": "felix.20241128003559.1",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241128003543.1",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241128003543.2",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241128003543.3",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241206235118.1",
          "vh": "Chapter 12 PIXEL_BUFFER Texture Arrays",
          "children": [
            {
              "gnx": "felix.20241206235118.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241206235118.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241206235118.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241206235118.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241207203355.1",
          "vh": "Chapter 12 too big PIXEL_BUFFER Texture Arrays",
          "children": [
            {
              "gnx": "felix.20241207203355.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241207203355.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241207203355.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241207203355.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241208003025.1",
          "vh": "Chapter 13 START Instanced Drawing",
          "children": [
            {
              "gnx": "felix.20241208003025.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241208003025.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241208003025.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241208003025.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241208150240.1",
          "vh": "Chapter 13 STEP-1 Instanced Drawing",
          "children": [
            {
              "gnx": "felix.20241208150240.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241208150240.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241208150240.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241208150240.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241208162017.1",
          "vh": "Chapter 13 STEP-2 Instanced Drawing",
          "children": [
            {
              "gnx": "felix.20241208162017.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241208162017.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241208162017.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241208162017.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241208172150.1",
          "vh": "Chapter 13 STEP-3 Instanced Drawing",
          "children": [
            {
              "gnx": "felix.20241208172150.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241208172150.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241208172150.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241208172150.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20241208211427.1",
          "vh": "Chapter 13 MORE Instanced Drawing",
          "children": [
            {
              "gnx": "felix.20241208211427.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20241208211427.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20241208211427.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20241208211427.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20250109205243.1",
          "vh": "Chapter 13 MAP-INSTANCED-SQUARE-WITH-COLOR",
          "children": [
            {
              "gnx": "felix.20250109205243.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20250109205243.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250109205243.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20250109205243.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20250111205945.1",
          "vh": "Chapter 13 Map instanced square with color and matrix",
          "children": [
            {
              "gnx": "felix.20250111205945.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20250111205945.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250111205945.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20250111205945.5",
                  "vh": "main"
                }
              ]
            },
            {
              "gnx": "felix.20250111220451.1",
              "vh": "Maths",
              "children": [
                {
                  "gnx": "felix.20250111220451.2",
                  "vh": "class Point",
                  "children": [
                    {
                      "gnx": "felix.20250111220451.3",
                      "vh": "constructor"
                    }
                  ]
                },
                {
                  "gnx": "felix.20250111220451.4",
                  "vh": "class M3x3",
                  "children": [
                    {
                      "gnx": "felix.20250111220451.5",
                      "vh": "constructor"
                    },
                    {
                      "gnx": "felix.20250111220451.6",
                      "vh": "multiply"
                    },
                    {
                      "gnx": "felix.20250111220451.7",
                      "vh": "translation"
                    },
                    {
                      "gnx": "felix.20250111220451.8",
                      "vh": "scale"
                    },
                    {
                      "gnx": "felix.20250111220451.9",
                      "vh": "getFloatArray"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20250115220303.1",
          "vh": "Chapter 13 Map instanced square with color and scaling uniforms",
          "children": [
            {
              "gnx": "felix.20250115220303.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20250115220303.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250115220303.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20250115220303.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20250116233756.1",
          "vh": "Chapter 13 MORE Instanced Drawing with color and scaling uniforms",
          "children": [
            {
              "gnx": "felix.20250116233756.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20250116233756.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250116233756.4",
                  "vh": "WebGL Program"
                },
                {
                  "gnx": "felix.20250116233756.5",
                  "vh": "main"
                }
              ]
            }
          ]
        },
        {
          "gnx": "felix.20250118202734.1",
          "vh": "Chapter 13 MORE Instanced Drawing with VAO",
          "children": [
            {
              "gnx": "felix.20250118202734.2",
              "vh": "gl sources"
            },
            {
              "gnx": "felix.20250118202734.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250118202734.4",
                  "vh": "WebGL Program"
                }
              ]
            },
            {
              "gnx": "felix.20250118202734.6",
              "vh": "BaseRenderer"
            },
            {
              "gnx": "felix.20250118203718.1",
              "vh": "SpriteRenderer"
            }
          ]
        },
        {
          "gnx": "felix.20250119014228.1",
          "vh": "Chapter 13 MORE Instanced Drawing VAO alien and map",
          "children": [
            {
              "gnx": "felix.20250119171554.1",
              "vh": "types"
            },
            {
              "gnx": "felix.20250119014228.2",
              "vh": "gl sources & tools"
            },
            {
              "gnx": "felix.20250119014228.3",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250119014228.4",
                  "vh": "WebGL Program"
                }
              ]
            },
            {
              "gnx": "felix.20250119014228.5",
              "vh": "BaseRenderer"
            },
            {
              "gnx": "felix.20250119014352.1",
              "vh": "TileRenderer"
            },
            {
              "gnx": "felix.20250119014228.6",
              "vh": "SpriteRenderer"
            }
          ]
        },
        {
          "gnx": "felix.20250119210437.1",
          "vh": "Chapter 13 MORE Instanced Drawing VAO, and UBO, alien and map ",
          "children": [
            {
              "gnx": "felix.20250119210437.2",
              "vh": "types"
            },
            {
              "gnx": "felix.20250119210437.3",
              "vh": "gl sources & tools"
            },
            {
              "gnx": "felix.20250119210437.4",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250119210437.5",
                  "vh": "WebGL Program"
                }
              ]
            },
            {
              "gnx": "felix.20250119210437.6",
              "vh": "BaseRenderer"
            },
            {
              "gnx": "felix.20250119210437.7",
              "vh": "TileRenderer"
            },
            {
              "gnx": "felix.20250119210437.8",
              "vh": "SpriteRenderer"
            }
          ]
        },
        {
          "gnx": "felix.20250121223733.1",
          "vh": "Instanced Drawing VAO, and UBO, alien and map, and lines",
          "children": [
            {
              "gnx": "felix.20250121223733.2",
              "vh": "types"
            },
            {
              "gnx": "felix.20250121223733.3",
              "vh": "gl sources & tools"
            },
            {
              "gnx": "felix.20250121223733.4",
              "vh": "Asynchronous IIFE",
              "children": [
                {
                  "gnx": "felix.20250121223733.5",
                  "vh": "WebGL Program"
                }
              ]
            },
            {
              "gnx": "felix.20250121223733.6",
              "vh": "BaseRenderer"
            },
            {
              "gnx": "felix.20250121223733.7",
              "vh": "TileRenderer"
            },
            {
              "gnx": "felix.20250121223733.8",
              "vh": "SpriteRenderer"
            },
            {
              "gnx": "felix.20250121225028.1",
              "vh": "RectangleRenderer"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20241113233458.1",
      "vh": "@clean src/main.ts",
      "children": [
        {
          "gnx": "felix.20250121223733.1"
        }
      ]
    }
  ],
  "tnodes": {
    "felix.20241113233438.1": "Andrew Adamson WebGL tutorials\n\nhttps://www.youtube.com/watch?v=-T6EbWCq99c&list=PLPbmjY2NVO_X1U1JzLxLDdRn4NmtxyQQo\n\n",
    "felix.20241118225416.1": "@language typescript\n@nowrap\n\n",
    "felix.20241118225308.1": "@others\n\n",
    "felix.20241118225357.1": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nvoid main()\n{\n    gl_PointSize = 150.0;\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}`;\n\n",
    "felix.20241118225400.1": "// Start\nconst canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link program');\n}\n\ngl.useProgram(program);\n\ngl.drawArrays(gl.POINTS, 0, 1);",
    "felix.20241116232514.1": "@others\n",
    "felix.20241113235415.1": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nuniform float uPointSize;\nuniform vec2 uPosition;\n\nvoid main()\n{\n    gl_PointSize = uPointSize;\n    gl_Position = vec4(uPosition, 0.0, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nout vec4 fragColor;\n\nuniform int uIndex;\nuniform vec4 uColors[3];\n\nvoid main()\n{\n    fragColor = uColors[uIndex];\n}`;\n\n",
    "felix.20241113235430.1": "// Start\nconst canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n// VERTEX SHADER -> Get position and pont size uniforms locations and set their values\nconst uPositionLoc = gl.getUniformLocation(program, 'uPosition')!;\ngl.uniform2f(uPositionLoc, -0.3, 0.0);\n\nconst uPointSizeLoc = gl.getUniformLocation(program, 'uPointSize')!;\ngl.uniform1f(uPointSizeLoc, 100.0);\n\n// FRAGMENT SHADER -> Get index and colors uniforms locations and set their values\nconst uIndexLoc = gl.getUniformLocation(program, 'uIndex')!;\nconst uColorsLoc = gl.getUniformLocation(program, 'uColors')!;\n\ngl.uniform1i(uIndexLoc, 2);\ngl.uniform4fv(uColorsLoc, [\n    1.0, 0.0, 0.0, 1.0,\n    0.0, 1.0, 0.0, 1.0,\n    1.0, 0.0, 1.0, 1.0,\n]);\n\ngl.drawArrays(gl.POINTS, 0, 1);\n",
    "felix.20241116232737.1": "@others\n",
    "felix.20241116232737.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location = 1) in float aPointSize;\nlayout(location = 0) in vec2 aPosition;\nlayout(location = 2) in vec3 aColor;\n\nout vec3 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    gl_PointSize = aPointSize;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec3 vColor;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vec4(vColor, 1.0);\n}`;\n\n",
    "felix.20241116232737.3": "// Start\nconst canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n// Attributes\nconst aPositionLoc = 0;\nconst aPointSizeLoc = 1;\nconst aColorLoc = 2;\n\ngl.vertexAttrib4f(aPositionLoc, 0, 0, 0, 1); // DEFAULT LOCATION\ngl.vertexAttrib1f(aPointSizeLoc, 50); // DEFAULT POINT SIZE\ngl.vertexAttrib4f(aColorLoc, 1, 0, 0, 1); // DEFAULT COLOR (RED)\n\n// * ALL IN SAME BUFFER AS FLOAT *\nconst bufferData = new Float32Array([\n    -0.3, 0.5, 100, 1, 0, 0,\n    0.3, -0.5, 10, 0, 1, 0,\n    0.8, 0.8, 50, 0, 0, 1,\n    0.4, -0.1, 70, 0.2, 0.5, 0.8,\n    0.1, 0.2, 20, 0.9, 0.2, 0.4,\n    0.4, 0.3, 30, 0.6, 0.6, 0.1\n]);\n\n// create 16 bits from floats\nconsole.log(\n    bufferData\n        .map((v: number) => Math.floor(v * (1 << 15)))\n        .reduce((c: string[], v: number) => [...c, v.toString(10).padStart(6)], [])\n        .join()\n);\n// * ALL IN SAME BUFFER AS SIGNED 16 BIT INT (-32767 to 32767, NOT 0-65536) *\nconst bufferData2 = new Int16Array([\n    -9831, 16384, 100, 32767, 0, 0,\n    9830, -16384, 10, 0, 32767, 0,\n    26214, 26214, 50, 0, 0, 32767,\n    13107, -3277, 70, 6553, 16384, 26214,\n    3276, 6553, 20, 29491, 6553, 13107,\n    13107, 9830, 30, 19660, 19660, 3276\n]);\n\n// create 8 bits from 16 bit\nconsole.log(\n    bufferData2\n        .map((v: number) => (v >> 8))\n        .reduce((c: string[], v: number) => [...c, v.toString(10).padStart(4)], [])\n        .join()\n);\n// * ALL IN SAME BUFFER AS SIGNED 8 BIT INT (-127 to 127, NOT 0-255) *\nconst bufferData3 = new Int8Array([\n    -39, 64, 100, 127, 0, 0,\n    38, -64, 10, 0, 127, 0,\n    102, 102, 50, 0, 0, 127,\n    51, -13, 70, 25, 64, 102,\n    12, 25, 20, 115, 25, 51,\n    51, 38, 30, 76, 76, 12\n]);\n\nconst buffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n// gl.bufferData(gl.ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);\n// gl.bufferData(gl.ARRAY_BUFFER, bufferData2, gl.STATIC_DRAW);\ngl.bufferData(gl.ARRAY_BUFFER, bufferData3, gl.STATIC_DRAW);\n\n// Bind attributes: Match the layout in the buffer data\n// gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 6 * 4, 0);\n// gl.vertexAttribPointer(aPointSizeLoc, 1, gl.FLOAT, false, 6 * 4, 2 * 4);\n// gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, 6 * 4, 3 * 4);\n\n// gl.vertexAttribPointer(aPositionLoc, 2, gl.SHORT, true, 6 * 2, 0);\n// gl.vertexAttribPointer(aPointSizeLoc, 1, gl.SHORT, false, 6 * 2, 2 * 2);\n// gl.vertexAttribPointer(aColorLoc, 3, gl.SHORT, true, 6 * 2, 3 * 2);\n\ngl.vertexAttribPointer(aPositionLoc, 2, gl.BYTE, true, 6 * 1, 0);\ngl.vertexAttribPointer(aPointSizeLoc, 1, gl.BYTE, false, 6 * 1, 2 * 1);\ngl.vertexAttribPointer(aColorLoc, 3, gl.BYTE, true, 6 * 1, 3 * 1);\n\n// * SEPARATE BUFFERS *\n// const positionData = new Float32Array([\n//     -0.3, 0.5,\n//     0.3, -0.5,\n//     0.8, 0.8,\n//     0.4, -0.1,\n//     0.1, 0.2,\n//     0.4, 0.3\n// ]);\n// const pointSizeData = new Float32Array([\n//     100,\n//     10,\n//     50,\n//     70,\n//     20,\n//     30\n// ]);\n// const colorData = new Float32Array([\n//     1, 0, 0,\n//     0, 1, 0,\n//     0, 0, 1,\n//     0.2, 0.5, 0.8,\n//     0.9, 0.2, 0.4,\n//     0.6, 0.6, 0.1\n// ]);\n\n// const positionBuffer = gl.createBuffer()!;\n// gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n// gl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);\n\n// const pointSizeBuffer = gl.createBuffer()!;\n// gl.bindBuffer(gl.ARRAY_BUFFER, pointSizeBuffer);\n// gl.bufferData(gl.ARRAY_BUFFER, pointSizeData, gl.STATIC_DRAW);\n\n// const colorBuffer = gl.createBuffer()!;\n// gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n// gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.STATIC_DRAW);\n\n// gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n// gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);\n\n// gl.bindBuffer(gl.ARRAY_BUFFER, pointSizeBuffer);\n// gl.vertexAttribPointer(aPointSizeLoc, 1, gl.FLOAT, false, 0, 0);\n\n// gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n// gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, 0, 0);\n\n// Comment any of those 3 lines to see the effect of DEFAULTS above\ngl.enableVertexAttribArray(aPointSizeLoc);\ngl.enableVertexAttribArray(aPositionLoc);\ngl.enableVertexAttribArray(aColorLoc);\n\ngl.drawArrays(gl.POINTS, 0, 6);  // Points sizes controled by third value in buffer data\n// gl.drawArrays(gl.LINE_LOOP, 0, 6); // Will draw a triangle\n// gl.drawArrays(gl.TRIANGLES, 0, 6); // Will draw a filled triangle\n",
    "felix.20241117233253.1": "@others\n",
    "felix.20241117233253.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location = 0) in vec4 aPosition;\nlayout(location = 1) in vec4 aColor;\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    gl_Position = aPosition;\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor;\n}`;\n\n",
    "felix.20241117233253.3": "// Start\nconst canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n// For usage with drawArrays\nconst arrayVertexData = new Float32Array([\n    0, 0, 1, 0, 0,\n    0.0, 1.0, 1, 0, 0,\n    0.951, 0.309, 1, 0, 0,\n\n    0, 0, 0, 1, 0,\n    0.951, 0.309, 0, 1, 0,\n    0.587, -0.809, 0, 1, 0,\n\n    0, 0, 0, 0, 1,\n    0.587, -0.809, 0, 0, 1,\n    -0.587, -0.809, 0, 0, 1,\n\n    0, 0, 1, 1, 0,\n    -0.587, -0.809, 1, 1, 0,\n    -0.951, 0.309, 1, 1, 0,\n\n    0, 0, 1, 0, 1,\n    -0.951, 0.309, 1, 0, 1,\n    0.0, 1.0, 1, 0, 1,\n\n]);\n\nconst arrayVertexDataBuffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, arrayVertexDataBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, arrayVertexData, gl.STATIC_DRAW);\n\n// For usage with drawElements\nconst elementVertexData = new Float32Array([\n    0, 0, 0, 0, 0,\n    0.0, 1.0, 1, 0, 0,\n    0.951, 0.309, 0, 1, 0,\n    0.587, -0.809, 0, 0, 1,\n    -0.587, -0.809, 1, 1, 0,\n    -0.951, 0.309, 1, 0, 1,\n]);\n\nconst elementIndexData = new Uint8Array([\n    0, 1, 2,\n    0, 2, 3,\n    0, 3, 4,\n    0, 4, 5,\n    0, 5, 1,\n]);\n\nconst elementVertexBuffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, elementVertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, elementVertexData, gl.STATIC_DRAW);\n\nconst elementIndexBuffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementIndexBuffer);\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elementIndexData, gl.STATIC_DRAW);\n\n// gl.bindBuffer(gl.ARRAY_BUFFER, arrayVertexBufferData);\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 5 * 4, 0);\ngl.vertexAttribPointer(1, 3, gl.FLOAT, false, 5 * 4, 2 * 4);\n\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\n\n// gl.drawArrays(gl.TRIANGLES, 0, 15);\ngl.drawElements(gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);\n",
    "felix.20241118225644.1": "@others\n",
    "felix.20241118225644.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vTexCoord = aTexCoord;\n    gl_Position = aPosition;\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec2 vTexCoord;\n\nout vec4 fragColor;\n\nuniform sampler2D uPixelSampler;\nuniform sampler2D uSpriteSampler;\n\nvoid main()\n{\n    // Sample demo mix of textures\n    fragColor = texture(uPixelSampler, vTexCoord) * texture(uSpriteSampler, vTexCoord);\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20241124171038.1": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241124171224.1": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241118225644.3": "const colors = new Uint8Array([\n    255, 255, 255, 142, 35, 344, 34, 127, 77, 127, 127, 127,\n    90, 212, 222, 43, 212, 122, 33, 22, 11, 213, 17, 78,\n    99, 88, 232, 22, 22, 11, 213, 111, 83, 211, 211, 22,\n    0, 0, 0, 244, 211, 231, 112, 112, 22, 73, 172, 243,\n]);\n\nconst image = await loadImage('images/sprite.png');\n\ngl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n\nconst vertexBufferData = new Float32Array([\n    -0.9, -0.9,\n    0.0, 0.9,\n    0.9, -0.9,\n]);\n\nconst texCoordBufferData = new Float32Array([\n    0, 0,\n    0.5, 1,\n    1, 0,\n]);\n\nconst vertexBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, vertexBufferData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(0);\n\nconst texCoordBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, texCoordBufferData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(1);\n\nconst pixelTextureUnit = 0;\nconst spriteTextureUnit = 5;\n\ngl.uniform1i(gl.getUniformLocation(program, 'uPixelSampler'), pixelTextureUnit);\ngl.uniform1i(gl.getUniformLocation(program, 'uSpriteSampler'), spriteTextureUnit);\n\nconst pixelTexture = gl.createTexture();\ngl.activeTexture(gl.TEXTURE0 + pixelTextureUnit);\ngl.bindTexture(gl.TEXTURE_2D, pixelTexture);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 4, 4, 0, gl.RGB, gl.UNSIGNED_BYTE, colors);\n// gl.generateMipmap(gl.TEXTURE_2D);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\nconst spriteTexture = gl.createTexture();\ngl.activeTexture(gl.TEXTURE0 + spriteTextureUnit);\ngl.bindTexture(gl.TEXTURE_2D, spriteTexture);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 32, 32, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);\n// gl.generateMipmap(gl.TEXTURE_2D);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n// Transparency\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// Draw call\ngl.drawArrays(gl.TRIANGLES, 0, 3);\n",
    "felix.20241126223424.1": "@others\n\nconst data2 = new Float32Array([\n    -0.8, -0.6, 1.0, 0.25, 0.25, 125,\n    -0.3, -0.6, 0.0, 0.25, 1.0, 32,\n    0.3, -0.6, 0.5, 1.0, 0.25, 75,\n    0.8, -0.6, 0.0, 0.25, 0.25, 9,\n]);\nconst buffer2 = gl.createBuffer()!;\n\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer2);\ngl.bufferData(gl.ARRAY_BUFFER, data2, gl.STATIC_DRAW);\n\ngl.vertexAttribPointer(0, 1, gl.FLOAT, false, 24, 20);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0);\ngl.vertexAttribPointer(2, 3, gl.FLOAT, false, 24, 8);\n\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.enableVertexAttribArray(2);\n\ngl.drawArrays(gl.POINTS, 0, 4);\n\n",
    "felix.20241126223424.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location = 0) in float aPointSize;\nlayout(location = 1) in vec2 aPosition;\nlayout(location = 2) in vec3 aColor;\n\nout vec3 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    gl_PointSize = aPointSize;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec3 vColor;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vec4(vColor, 1.0);\n}`;\n\n",
    "felix.20241126223424.3": "// Start\nconst canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link program');\n}\n\ngl.useProgram(program);\n\nconst data1 = new Float32Array([\n    -0.8, 0.6, 1.0, 0.75, 0.75, 125,\n    -0.3, 0.6, 0.0, 0.75, 1.0, 32,\n    0.3, 0.6, 0.5, 1.0, 0.75, 75,\n    0.8, 0.6, 0.0, 0.75, 0.75, 9,\n]);\nconst buffer1 = gl.createBuffer()!;\n\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer1);\ngl.bufferData(gl.ARRAY_BUFFER, data1, gl.STATIC_DRAW);\n\ngl.vertexAttribPointer(0, 1, gl.FLOAT, false, 24, 20);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0);\ngl.vertexAttribPointer(2, 3, gl.FLOAT, false, 24, 8);\n\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.enableVertexAttribArray(2);\n\ngl.drawArrays(gl.POINTS, 0, 4);\n",
    "felix.20241124205404.1": "@others\n\nconst data2 = new Float32Array([\n    -0.8, -0.6, 1.0, 0.25, 0.25, 125,\n    -0.3, -0.6, 0.0, 0.25, 1.0, 32,\n    0.3, -0.6, 0.5, 1.0, 0.25, 75,\n    0.8, -0.6, 0.0, 0.25, 0.25, 9,\n]);\nconst buffer2 = gl.createBuffer()!;\n\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer2);\ngl.bufferData(gl.ARRAY_BUFFER, data2, gl.STATIC_DRAW);\n\n// Again, no need bind second buffer inside of the VAO, because vertexAttribPointer will do it for us.\nconst vao2 = gl.createVertexArray()!;\ngl.bindVertexArray(vao2);\n\ngl.vertexAttribPointer(0, 1, gl.FLOAT, false, 24, 20); // 20 because last after 5*4\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0); // 0 because those x/y are at start\ngl.vertexAttribPointer(2, 3, gl.FLOAT, false, 24, 8); // 8 because after 2 * 4\n\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.enableVertexAttribArray(2);\n\ngl.bindVertexArray(null); // Another snapshot has been taken\n\nconst draw = () => {\n    gl.bindVertexArray(vao1);\n    gl.drawArrays(gl.POINTS, 0, 4);\n    gl.bindVertexArray(null);\n\n    gl.bindVertexArray(vao2);\n    gl.drawArrays(gl.POINTS, 0, 4);\n    gl.bindVertexArray(null);\n\n    requestAnimationFrame(draw);\n}\n\ndraw();\n\n// gl.enableVertexAttribArray(0);\n// gl.enableVertexAttribArray(1);\n// gl.enableVertexAttribArray(2);\n\n// gl.drawArrays(gl.POINTS, 0, 4); // Draw the second set of points\n\n// gl.flush(); // Simulate the next frame\n// gl.clear(gl.COLOR_BUFFER_BIT);\n\n// gl.bindBuffer(gl.ARRAY_BUFFER, buffer1); // Have to rebind the buffer\n// gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 24, 20);\n// gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0);\n// gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 24, 8);\n\n// gl.drawArrays(gl.POINTS, 0, 4); // Draw the first set of points\n\n// gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);\n// gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 24, 20);\n// gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0);\n// gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 24, 8);\n\n// gl.drawArrays(gl.POINTS, 0, 4); // Draw the second set of points\n",
    "felix.20241124205404.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location = 0) in float aPointSize;\nlayout(location = 1) in vec2 aPosition;\nlayout(location = 2) in vec3 aColor;\n\nout vec3 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    gl_PointSize = aPointSize;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec3 vColor;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vec4(vColor, 1.0);\n}`;\n\n",
    "felix.20241124205404.3": "// Start\nconst canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link program');\n}\n\ngl.useProgram(program);\n\nconst data1 = new Float32Array([\n    -0.8, 0.6, 1.0, 0.75, 0.75, 125,\n    -0.3, 0.6, 0.0, 0.75, 1.0, 32,\n    0.3, 0.6, 0.5, 1.0, 0.75, 75,\n    0.8, 0.6, 0.0, 0.75, 0.75, 9,\n]);\nconst buffer1 = gl.createBuffer()!;\n\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer1);\ngl.bufferData(gl.ARRAY_BUFFER, data1, gl.STATIC_DRAW);\n\n// No need to bindBuffer inside of the VAO, because vertexAttribPointer will do it for us.\nconst vao1 = gl.createVertexArray()!;\ngl.bindVertexArray(vao1);\n\ngl.vertexAttribPointer(0, 1, gl.FLOAT, false, 24, 20);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0);\ngl.vertexAttribPointer(2, 3, gl.FLOAT, false, 24, 8);\n\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.enableVertexAttribArray(2);\n\ngl.bindVertexArray(null); // Snapshot has been taken\n",
    "felix.20241201235534.1": "@others\n",
    "felix.20241201235534.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vTexCoord = aTexCoord;\n    gl_Position = aPosition;\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uSampler;\n\nin vec2 vTexCoord;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    // Sample demo mix of textures\n    fragColor = texture(uSampler, vTexCoord);\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\nfunction getSpriteUV(sprite: number, orientation: number): [number, number, number, number, number, number, number, number, number, number, number, number] {\n\n    const h = 64 / 4096;\n    const w = 64 / 4096;\n\n    // The sprite number (0 to 255) is the index of the 64x64 sprite in the 1024x1024 sprite sub-sheet\n    // The orientation is the index (0 to 15) of the 1024x1024 sprite sub-sheet in the 4096x4096 sprite sheet.\n\n    // Calculate in the 1024x1024 sprite sub-sheet and \n    // add the offset of the 1024x1024 sprite sub-sheet in the 4096x4096 sprite sheet\n    const u = ((sprite % 16) * w) + (orientation % 4) * 0.25;\n    const v = (Math.floor(sprite / 16) * h) + Math.floor(orientation / 4) * 0.25;\n\n    return [\n        u, v + h,\n        u + w, v,\n        u, v,\n\n        u, v + h,\n        u + w, v + h,\n        u + w, v\n\n    ];\n}\n\n",
    "felix.20241201235534.3": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241201235534.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241201235534.5": "\nconst positionData = new Float32Array([\n    // Quad 1\n    -1, 0,\n    0, 1,\n    -1, 1,\n    -1, 0,\n    0, 0,\n    0, 1,\n    // Quad 2\n    0, 0,\n    1, 1,\n    0, 1,\n    0, 0,\n    1, 0,\n    1, 1,\n    // Quad 3\n    -1, -1,\n    0, 0,\n    -1, 0,\n    -1, -1,\n    0, -1,\n    0, 0,\n    // Quad 4\n    0, -1,\n    1, 0,\n    0, 0,\n    0, -1,\n    1, -1,\n    1, 0,\n]);\n\nconst image = await loadImage('images/alien.png');\n\n// Flip Y not needed?\n// gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n\nconst positionBuffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(0);\n\nconst texCoordData = new Float32Array(2 * 4 * 6);\nconst texCoordBuffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, texCoordData.byteLength, gl.DYNAMIC_DRAW);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(1);\n\n// Set texture\ntexCoordData.set(getSpriteUV(120, 15), 0);\ntexCoordData.set(getSpriteUV(120, 0), 12);\ntexCoordData.set(getSpriteUV(120, 1), 24);\ntexCoordData.set(getSpriteUV(120, 2), 36);\ngl.bufferSubData(gl.ARRAY_BUFFER, 0, texCoordData);\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D, texture);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4096, 4096, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);\ngl.generateMipmap(gl.TEXTURE_2D);\n\n// Transparency\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// Draw call\ngl.drawArrays(gl.TRIANGLES, 0, 24);\n",
    "felix.20241126234030.1": "@others\n\n",
    "felix.20241128003559.1": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\nlayout(location=2) in float aDepth;\n\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    gl_Position = aPosition;\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec2 vTexCoord;\nin float vDepth;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20241128003543.1": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241128003543.2": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241128003543.3": "// * Start Program *\n\nconst positionData = new Float32Array([\n    -1, -1, 0, 1,\n    1, 1, 1, 0,\n    -1, 1, 0, 0,\n    -1, -1, 0, 1,\n    1, -1, 1, 1,\n    1, 1, 1, 0\n]);\n\n// const image = await loadImage('images/alien-vertical.png'); // Too big\nconst image = await loadImage('images/plancher-vertical.png');\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);\ngl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, 128, 128, 64, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\nconst buffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.vertexAttrib1f(2, 7); // Depth: change second parameter to change sprite.\n\n// Transparency\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// Draw call\ngl.generateMipmap(gl.TEXTURE_2D_ARRAY)\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_BASE_LEVEL, 0);\ngl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20241206235118.1": "@others\n",
    "felix.20241206235118.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\nlayout(location=2) in float aDepth;\n\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    gl_Position = aPosition;\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec2 vTexCoord;\nin float vDepth;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\nfunction getImageData(image: HTMLImageElement): Uint8ClampedArray {\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const context = canvas.getContext('2d')!;\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, image.width, image.height).data;\n}\n\n",
    "felix.20241206235118.3": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20241206235118.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241206235118.5": "// * Start Program *\n\nconst positionData = new Float32Array([\n    -1, -1, 0, 1,\n    1, 1, 1, 0,\n    -1, 1, 0, 0,\n    -1, -1, 0, 1,\n    1, -1, 1, 1,\n    1, 1, 1, 0\n]);\n\n// const image = await loadImage('images/alien-vertical.png');\n// const image = await loadImage('images/plancher-vertical.png');\nconst image = await loadImage('images/plancher2.png'); // plancher 2 is 24 bits\nconst imageData = getImageData(image);\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);\ngl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, 128, 128, 64);\n\nconst pbo = gl.createBuffer()!;\ngl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, pbo);\ngl.bufferData(gl.PIXEL_UNPACK_BUFFER, imageData, gl.STATIC_DRAW);\ngl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);\ngl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);\n\nfor (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, x * 128);\n        gl.pixelStorei(gl.UNPACK_SKIP_ROWS, y * 128);\n        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, y * 8 + x, 128, 128, 1, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n    }\n}\n\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\nconst buffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.vertexAttrib1f(2, 0); // Depth: change second parameter to change sprite.\n\n// Transparency\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// Draw call\ngl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20241207203355.1": "@others\n",
    "felix.20241207203355.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\nlayout(location=2) in float aDepth;\n\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    gl_Position = aPosition;\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec2 vTexCoord;\nin float vDepth;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\nfunction getImageData(image: HTMLImageElement): Uint8ClampedArray {\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width;\n    canvas.height = image.height;\n    const context = canvas.getContext('2d')!;\n    context.drawImage(image, 0, 0);\n    return context.getImageData(0, 0, image.width, image.height).data;\n}\n\n",
    "felix.20241207203355.3": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20241207203355.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241207203355.5": "// * Start Program *\n\nconst positionData = new Float32Array([\n    -1, -1, 0, 1,\n    1, 1, 1, 0,\n    -1, 1, 0, 0,\n    -1, -1, 0, 1,\n    1, -1, 1, 1,\n    1, 1, 1, 0\n]);\n\n// const image = await loadImage('images/alien-vertical.png');\n// const image = await loadImage('images/plancher-vertical.png');\n// const image = await loadImage('images/plancher2.png');\nconst image = await loadImage('images/alien.png');\nconst imageData = getImageData(image);\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);\ngl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, 64, 64, 4096);\n\nconst pbo = gl.createBuffer()!;\ngl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, pbo);\ngl.bufferData(gl.PIXEL_UNPACK_BUFFER, imageData, gl.STATIC_DRAW);\ngl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);\ngl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);\n\nfor (let y = 0; y < 8; y++) {\n    for (let x = 0; x < 8; x++) {\n        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, x * 64);\n        gl.pixelStorei(gl.UNPACK_SKIP_ROWS, y * 64);\n        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, y * 8 + x, 64, 64, 1, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n    }\n}\n\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\nconst buffer = gl.createBuffer()!;\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.vertexAttrib1f(2, 0); // Depth: change second parameter to change sprite.\n\n// Transparency\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// Draw call\ngl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20241208003025.1": "@others\n\n",
    "felix.20241208003025.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScale;\nlayout(location=3) in vec4 aColor;\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor;\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20241208003025.3": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241208003025.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241208003025.5": "// * Start Program *\n\nconst modelData = new Float32Array([\n    // position, offset,     scale, color    \n    -1, -0.7, -0.2, 0.7, 0.1, 1, 0, 0,\n    0, 0.8, -0.2, 0.7, 0.1, 1, 0, 0,\n    1, -0.7, -0.2, 0.7, 0.1, 1, 0, 0,\n\n    -1, -0.7, 0.3, -0.5, 0.4, 0, 0, 1,\n    0, 0.8, 0.3, -0.5, 0.4, 0, 0, 1,\n    1, -0.7, 0.3, -0.5, 0.4, 0, 0, 1,\n]);\n\nconst modelBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW);\n\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8 * 4, 0);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 8 * 4, 8);\ngl.vertexAttribPointer(2, 1, gl.FLOAT, false, 8 * 4, 16);\ngl.vertexAttribPointer(3, 3, gl.FLOAT, false, 8 * 4, 20);\n\ngl.enableVertexAttribArray(0);\ngl.enableVertexAttribArray(1);\ngl.enableVertexAttribArray(2);\ngl.enableVertexAttribArray(3);\n\n// Transparency\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// Draw call\ngl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20241208150240.1": "@others\n\n",
    "felix.20241208150240.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScale;\nlayout(location=3) in vec4 aColor;\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor;\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20241208150240.3": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241208150240.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241208150240.5": "// * Start Program *\n\nconst modelData = new Float32Array([\n    -1, -0.7,\n    0, 0.8,\n    1, -0.7,\n]);\n\nconst transformData = new Float32Array([\n    -0.2, 0.7, 0.1, 1, 0, 0,\n    0.3, -0.5, 0.4, 0, 0, 1,\n    -0.4, 0.2, 0.2, 1, 0, 1,\n]);\n\nconst modelBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW);\n\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(0);\n\nfor (let i = 0; i < transformData.length; i += 6) {\n    gl.vertexAttrib2fv(1, transformData.slice(i, i + 2));\n    gl.vertexAttrib1fv(2, transformData.slice(i + 2, i + 3));\n    gl.vertexAttrib3fv(3, transformData.slice(i + 3, i + 6));\n\n    gl.drawArrays(gl.TRIANGLES, 0, 3);\n}\n\n// gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8 * 4, 0);\n// gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 8 * 4, 8);\n// gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 8 * 4, 16);\n// gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 8 * 4, 20);\n\n// gl.enableVertexAttribArray(0);\n// gl.enableVertexAttribArray(1);\n// gl.enableVertexAttribArray(2);\n// gl.enableVertexAttribArray(3);\n\n// // Transparency\n// gl.enable(gl.BLEND);\n// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// // Draw call\n// gl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20241208162017.1": "@others\n\n",
    "felix.20241208162017.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScale;\nlayout(location=3) in vec4 aColor;\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor;\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20241208162017.3": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241208162017.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241208162017.5": "// * Start Program *\n\nconst modelData = new Float32Array([\n    -1, -0.7,\n    0, 0.8,\n    1, -0.7,\n]);\n\nconst transformData = new Float32Array([\n    -0.2, 0.7, 0.1, 1, 0, 0,\n    0.3, -0.5, 0.4, 0, 0, 1,\n    -0.4, 0.2, 0.2, 1, 0, 1,\n]);\n\nconst modelBuffer = gl.createBuffer(); // Create a buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW); // Put data in the buffer\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0); // Describe the data in the buffer with a size of 2 because it's a 2D model, and a stride and offset of 0 because the data is tightly packed\ngl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\n\nconst transformBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\ngl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 24, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\ngl.vertexAttribPointer(2, 1, gl.FLOAT, false, 24, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\ngl.vertexAttribPointer(3, 3, gl.FLOAT, false, 24, 12); // Describe the data in the buffer, the color (after 12 bytes of the 2 floats for x and y and the 1 float for scale)\n\ngl.vertexAttribDivisor(1, 1); // Tell the GPU to update the position attribute every instance\ngl.vertexAttribDivisor(2, 1); // Tell the GPU to update the scale attribute every instance\ngl.vertexAttribDivisor(3, 1); // Tell the GPU to update the color attribute every instance\n\ngl.enableVertexAttribArray(1); // Enable the attribute\ngl.enableVertexAttribArray(2); // Enable the attribute\ngl.enableVertexAttribArray(3); // Enable the attribute\n\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 3);\n\n// for (let i = 0; i < transformData.length; i += 6) {\n//     gl.vertexAttrib2fv(1, transformData.slice(i, i + 2));\n//     gl.vertexAttrib1fv(2, transformData.slice(i + 2, i + 3));\n//     gl.vertexAttrib3fv(3, transformData.slice(i + 3, i + 6));\n\n//     gl.drawArrays(gl.TRIANGLES, 0, 3);\n// }\n\n// gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8 * 4, 0);\n// gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 8 * 4, 8);\n// gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 8 * 4, 16);\n// gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 8 * 4, 20);\n\n// gl.enableVertexAttribArray(0);\n// gl.enableVertexAttribArray(1);\n// gl.enableVertexAttribArray(2);\n// gl.enableVertexAttribArray(3);\n\n// // Transparency\n// gl.enable(gl.BLEND);\n// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// // Draw call\n// gl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20241208172150.1": "@others\n\n",
    "felix.20241208172150.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScale;\nlayout(location=3) in vec4 aColor;\nlayout(location=4) in vec2 aTexCoord;\nlayout(location=5) in float aDepth;\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20241208172150.3": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241208172150.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241208172150.5": "// * Start Program *\n\nconst image = await loadImage('images/plancher-vertical.png');\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);\ngl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, 128, 128, 64, 0, gl.RGBA, gl.UNSIGNED_BYTE, image); // 64 textures of 128x128 pixels\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n// gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n// gl.generateMipmap(gl.TEXTURE_2D); // TODO : GENERATE MIPMAPS ?\n\nconst modelData = new Float32Array([\n    // Position   texCoord\n    -1, -0.7, 0, 1,\n    0, 0.8, 0.5, 0,\n    1, -0.7, 1, 1,\n]);\n\nconst transformData = new Float32Array([\n    // posX, posY, scale, colorR, colorG, colorB, depth (7 total is 28 bytes)\n    -0.2, 0.7, 0.1, 1, 0, 0, 0,\n    0.3, -0.5, 0.4, 0, 0, 1, 1,\n    -0.4, 0.2, 0.2, 1, 0, 1, 22,\n]);\n\nconst modelBuffer = gl.createBuffer(); // Create a buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW); // Put data in the buffer\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0); // Describe the data in the buffer with a size of 2 because it's a 2D model, and a stride and offset of 0 because the data is tightly packed\ngl.vertexAttribPointer(4, 2, gl.FLOAT, false, 16, 8);\ngl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\ngl.enableVertexAttribArray(4);\n\nconst transformBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\ngl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 28, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\ngl.vertexAttribPointer(2, 1, gl.FLOAT, false, 28, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\ngl.vertexAttribPointer(3, 3, gl.FLOAT, false, 28, 12); // Describe the data in the buffer, the color (after 12 bytes of the 2 floats for x and y and the 1 float for scale)\ngl.vertexAttribPointer(5, 1, gl.FLOAT, false, 28, 24); // Describe the data in the buffer, the depth (after 24 bytes of the 2 floats for x and y and the 1 float for scale and the 3 floats for color)\n\ngl.vertexAttribDivisor(1, 1); // Tell the GPU to update the position attribute every instance\ngl.vertexAttribDivisor(2, 1); // Tell the GPU to update the scale attribute every instance\ngl.vertexAttribDivisor(3, 1); // Tell the GPU to update the color attribute every instance\ngl.vertexAttribDivisor(5, 1); // Tell the GPU to update the color attribute every instance\n\ngl.enableVertexAttribArray(1); // Enable the attribute\ngl.enableVertexAttribArray(2); // Enable the attribute\ngl.enableVertexAttribArray(3); // Enable the attribute\ngl.enableVertexAttribArray(5); // Enable the attribute\n\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 3);\n\n// * End Program *\n\n// for (let i = 0; i < transformData.length; i += 6) {\n//     gl.vertexAttrib2fv(1, transformData.slice(i, i + 2));\n//     gl.vertexAttrib1fv(2, transformData.slice(i + 2, i + 3));\n//     gl.vertexAttrib3fv(3, transformData.slice(i + 3, i + 6));\n\n//     gl.drawArrays(gl.TRIANGLES, 0, 3);\n// }\n\n// gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8 * 4, 0);\n// gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 8 * 4, 8);\n// gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 8 * 4, 16);\n// gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 8 * 4, 20);\n\n// gl.enableVertexAttribArray(0);\n// gl.enableVertexAttribArray(1);\n// gl.enableVertexAttribArray(2);\n// gl.enableVertexAttribArray(3);\n\n// // Transparency\n// gl.enable(gl.BLEND);\n// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// // Draw call\n// gl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20241208211427.1": "@others\n\n",
    "felix.20241208211427.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec2 aUV;\n\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec2 vTexCoord;\n\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = texture(uSampler, vTexCoord);\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n",
    "felix.20241208211427.3": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20241208211427.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20241208211427.5": "// * Start Program *\n\nconst image = await loadImage('images/alien.png');\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D, texture);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4096, 4096, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);\ngl.generateMipmap(gl.TEXTURE_2D);\n\nconst modelData = new Float32Array([\n    // XY Coords, UV Offset to be multiplied by 0.015625 and added to the UV coordinates\n    -1, 0, 0, 1,\n    0, 1, 1, 0,\n    -1, 1, 0, 0,\n    // XY   UV\n    -1, 0, 0, 1,\n    0, 0, 1, 1,\n    0, 1, 1, 0,\n]);\n\nconst u = (sprite: number, orientation: number) => { return ((sprite % 16) * 0.015625) + (orientation % 4) * 0.25; }\n\nconst v = (sprite: number, orientation: number) => { return (Math.floor(sprite / 16) * 0.015625) + Math.floor(orientation / 4) * 0.25; }\n\nconst transformData = new Float32Array([\n    // posX, posY, scale, U(frame, orientation), V(frame, orientation) Usually set by game engine.\n    0.2, -0.5, 1.5, u(0, 0), v(0, 0),\n    0.2, 0.5, 0.3, u(0, 1), v(0, 1),\n    0.4, 0.2, 0.1, u(1, 1), v(1, 1),\n]);\n\nconst modelBuffer = gl.createBuffer(); // Create a buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW); // Put data in the buffer\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);  // XY\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8); // UV Offset\ngl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\ngl.enableVertexAttribArray(1);\n\nconst transformBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\ngl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(2, 2, gl.FLOAT, false, 20, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\ngl.vertexAttribPointer(3, 1, gl.FLOAT, false, 20, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\ngl.vertexAttribPointer(4, 3, gl.FLOAT, false, 20, 12); // Describe the data in the buffer\n\ngl.vertexAttribDivisor(2, 1); // Tell the GPU to update the position attribute every instance\ngl.vertexAttribDivisor(3, 1); // Tell the GPU to update the scale attribute every instance\ngl.vertexAttribDivisor(4, 1); // Tell the GPU to update the color attribute every instance\n\ngl.enableVertexAttribArray(2); // Enable the attribute\ngl.enableVertexAttribArray(3); // Enable the attribute\ngl.enableVertexAttribArray(4); // Enable the attribute\n\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 6, 3);\n\n// * End Program *\n\n// for (let i = 0; i < transformData.length; i += 6) {\n//     gl.vertexAttrib2fv(1, transformData.slice(i, i + 2));\n//     gl.vertexAttrib1fv(2, transformData.slice(i + 2, i + 3));\n//     gl.vertexAttrib3fv(3, transformData.slice(i + 3, i + 6));\n\n//     gl.drawArrays(gl.TRIANGLES, 0, 3);\n// }\n\n// gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8 * 4, 0);\n// gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 8 * 4, 8);\n// gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 8 * 4, 16);\n// gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 8 * 4, 20);\n\n// gl.enableVertexAttribArray(0);\n// gl.enableVertexAttribArray(1);\n// gl.enableVertexAttribArray(2);\n// gl.enableVertexAttribArray(3);\n\n// // Transparency\n// gl.enable(gl.BLEND);\n// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// // Draw call\n// gl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20250109205243.1": "@others\n\n",
    "felix.20250109205243.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScale;\nlayout(location=3) in vec4 aColor;\nlayout(location=4) in vec2 aTexCoord;\nlayout(location=5) in float aDepth;\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor =  vColor *  texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250109205243.3": "(async () => {\n\n    @others\n\n})();\n",
    "felix.20250109205243.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20250109205243.5": "// * Start Program *\n\nconst image = await loadImage('images/plancher-vertical.png');\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);\ngl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, 128, 128, 64, 0, gl.RGBA, gl.UNSIGNED_BYTE, image); // 64 textures of 128x128 pixels\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\ngl.generateMipmap(gl.TEXTURE_2D);\n\nconst modelData = new Float32Array([\n    // Position   texCoord\n    // XY Coords, UV Offset \n    -1, 0, 0, 1,\n    0, 1, 1, 0,\n    -1, 1, 0, 0,\n    // XY   UV\n    -1, 0, 0, 1,\n    0, 0, 1, 1,\n    0, 1, 1, 0,\n]);\n\nconst transformData = new Float32Array([\n    // posX, posY, scale, colorR, colorG, colorB, depth (7 total is 28 bytes)\n    -0.5, -1.0, 0.1, 0, 1.5, 0, 0,\n    0.0, 0.0, 0.4, 0, 0, 1, 1,\n    0.5, 0.5, 0.2, 1, 0, 1, 22,\n]);\n\nconst modelBuffer = gl.createBuffer(); // Create a buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW); // Put data in the buffer\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0); // Describe the data in the buffer with a size of 2 because it's a 2D model, and a stride and offset of 0 because the data is tightly packed\ngl.vertexAttribPointer(4, 2, gl.FLOAT, false, 16, 8);\ngl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\ngl.enableVertexAttribArray(4);\n\nconst transformBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\ngl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 28, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\ngl.vertexAttribPointer(2, 1, gl.FLOAT, false, 28, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\ngl.vertexAttribPointer(3, 3, gl.FLOAT, false, 28, 12); // Describe the data in the buffer, the color (after 12 bytes of the 2 floats for x and y and the 1 float for scale)\ngl.vertexAttribPointer(5, 1, gl.FLOAT, false, 28, 24); // Describe the data in the buffer, the depth (after 24 bytes of the 2 floats for x and y and the 1 float for scale and the 3 floats for color)\n\ngl.vertexAttribDivisor(1, 1); // Tell the GPU to update the position attribute every instance\ngl.vertexAttribDivisor(2, 1); // Tell the GPU to update the scale attribute every instance\ngl.vertexAttribDivisor(3, 1); // Tell the GPU to update the color attribute every instance\ngl.vertexAttribDivisor(5, 1); // Tell the GPU to update the depth attribute every instance\n\ngl.enableVertexAttribArray(1); // Enable the attribute\ngl.enableVertexAttribArray(2); // Enable the attribute\ngl.enableVertexAttribArray(3); // Enable the attribute\ngl.enableVertexAttribArray(5); // Enable the attribute\n\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 6, 3);\n\n// * End Program *\n\n// for (let i = 0; i < transformData.length; i += 6) {\n//     gl.vertexAttrib2fv(1, transformData.slice(i, i + 2));\n//     gl.vertexAttrib1fv(2, transformData.slice(i + 2, i + 3));\n//     gl.vertexAttrib3fv(3, transformData.slice(i + 3, i + 6));\n\n//     gl.drawArrays(gl.TRIANGLES, 0, 3);\n// }\n\n// gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8 * 4, 0);\n// gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 8 * 4, 8);\n// gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 8 * 4, 16);\n// gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 8 * 4, 20);\n\n// gl.enableVertexAttribArray(0);\n// gl.enableVertexAttribArray(1);\n// gl.enableVertexAttribArray(2);\n// gl.enableVertexAttribArray(3);\n\n// // Transparency\n// gl.enable(gl.BLEND);\n// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n// // Draw call\n// gl.drawArrays(gl.TRIANGLES, 0, 6);\n",
    "felix.20250111205945.1": "@others\n\n",
    "felix.20250111205945.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nuniform mat3 uWorld; // The world matrix mapping 400 by 300 to -1 to 1\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    gl_Position = vec4(uWorld * pos, 1.0);\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor =  vColor * texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250111205945.3": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20250111205945.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader compilation failed');\n}\n\ngl.useProgram(program);\n\n",
    "felix.20250111205945.5": "// * Start Program *\n\nconst image = await loadImage('images/plancher-vertical.png');\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);\ngl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, 128, 128, 64, 0, gl.RGBA, gl.UNSIGNED_BYTE, image); // 64 textures of 128x128 pixels\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\ngl.generateMipmap(gl.TEXTURE_2D_ARRAY);\n\nconst worldSpaceMatrix = new M3x3()\n    .translation(-100, -100)\n    .scale(2 / 400, -2 / 300)\n\nconst uWorldLoc = gl.getUniformLocation(program, 'uWorld')!;\ngl.uniformMatrix3fv(uWorldLoc, false, worldSpaceMatrix.getFloatArray());\n\n// Create a buffer for the model data of two triangles that form a rectangle\nconst modelData = new Float32Array([\n    // XY Coords, UV Offset \n    -1, 0, 0, 1,\n    0, 1, 1, 0,\n    -1, 1, 0, 0,\n    -1, 0, 0, 1,\n    0, 0, 1, 1,\n    0, 1, 1, 0,\n]);\n\n// Create a buffer for the transformation data of the three instances\n\n// Test data with posX and posY for a 400x300 resolution instead of -1 to 1.\nconst transformData = new Float32Array([\n    // posX, posY, scale, colorR, colorG, colorB, depth\n    0, 0, 16, 0, 1.5, 0, 0,      // Green Test at origin\n    200, 150, 24, 0, 0, 1, 1,    // Blue Test at center\n    400, 300, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n]);\n\nconst modelBuffer = gl.createBuffer(); // Create a buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW); // Put data in the buffer\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0); // Describe the data in the buffer with a size of 2 because it's a 2D model, and a stride of 16 bytes because there are 4 floats per vertex\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);\ngl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\ngl.enableVertexAttribArray(1);\ngl.vertexAttribDivisor(0, 0); // Model vertices - changes every vertex\ngl.vertexAttribDivisor(1, 0); // Texture coords - changes every vertex\n\nconst transformBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\ngl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(2, 2, gl.FLOAT, false, 28, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\ngl.vertexAttribPointer(3, 1, gl.FLOAT, false, 28, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\ngl.vertexAttribPointer(4, 3, gl.FLOAT, false, 28, 12); // Describe the data in the buffer, the color (after 12 bytes of the 2 floats for x and y and the 1 float for scale)\ngl.vertexAttribPointer(5, 1, gl.FLOAT, false, 28, 24); // Describe the data in the buffer, the depth (after 24 bytes of the 2 floats for x and y and the 1 float for scale and the 3 floats for color)\n\ngl.vertexAttribDivisor(2, 1); // Tell the GPU to update the position attribute every instance\ngl.vertexAttribDivisor(3, 1); // Tell the GPU to update the scale attribute every instance\ngl.vertexAttribDivisor(4, 1); // Tell the GPU to update the color attribute every instance\ngl.vertexAttribDivisor(5, 1); // Tell the GPU to update the depth attribute every instance\n\ngl.enableVertexAttribArray(2); // Enable the attribute\ngl.enableVertexAttribArray(3); // Enable the attribute\ngl.enableVertexAttribArray(4); // Enable the attribute\ngl.enableVertexAttribArray(5); // Enable the attribute\n\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 6, 3); // Draw the model of 6 vertex that form 2 triangles, 3 times\n\n// * End Program *\n\n",
    "felix.20250111220451.1": "@language typescript\n",
    "felix.20250111220451.2": "class Point {\n\n    public x: number;\n    public y: number;\n\n    @others\n}\n\n",
    "felix.20250111220451.3": "constructor(x = 0.0, y = 0.0) {\n    this.x = x;\n    this.y = y;\n}\n\n",
    "felix.20250111220451.4": "class M3x3 {\n\n    public static M00 = 0;\n    public static M01 = 1;\n    public static M02 = 2;\n    public static M10 = 3;\n    public static M11 = 4;\n    public static M12 = 5;\n    public static M20 = 6;\n    public static M21 = 7;\n    public static M22 = 8;\n\n    public matrix: [\n        number, number, number,\n        number, number, number,\n        number, number, number,\n    ];\n\n    @others\n\n}\n\n",
    "felix.20250111220451.5": "constructor() {\n    this.matrix = [\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1\n    ];\n}\n\n",
    "felix.20250111220451.6": "multiply(m: M3x3): M3x3 {\n    const output = new M3x3();\n    output.matrix = [\n        this.matrix[M3x3.M00] * m.matrix[M3x3.M00] + this.matrix[M3x3.M10] * m.matrix[M3x3.M01] + this.matrix[M3x3.M20] * m.matrix[M3x3.M02],\n        this.matrix[M3x3.M01] * m.matrix[M3x3.M00] + this.matrix[M3x3.M11] * m.matrix[M3x3.M01] + this.matrix[M3x3.M21] * m.matrix[M3x3.M02],\n        this.matrix[M3x3.M02] * m.matrix[M3x3.M00] + this.matrix[M3x3.M12] * m.matrix[M3x3.M01] + this.matrix[M3x3.M22] * m.matrix[M3x3.M02],\n\n        this.matrix[M3x3.M00] * m.matrix[M3x3.M10] + this.matrix[M3x3.M10] * m.matrix[M3x3.M11] + this.matrix[M3x3.M20] * m.matrix[M3x3.M12],\n        this.matrix[M3x3.M01] * m.matrix[M3x3.M10] + this.matrix[M3x3.M11] * m.matrix[M3x3.M11] + this.matrix[M3x3.M21] * m.matrix[M3x3.M12],\n        this.matrix[M3x3.M02] * m.matrix[M3x3.M10] + this.matrix[M3x3.M12] * m.matrix[M3x3.M11] + this.matrix[M3x3.M22] * m.matrix[M3x3.M12],\n\n        this.matrix[M3x3.M00] * m.matrix[M3x3.M20] + this.matrix[M3x3.M10] * m.matrix[M3x3.M21] + this.matrix[M3x3.M20] * m.matrix[M3x3.M22],\n        this.matrix[M3x3.M01] * m.matrix[M3x3.M20] + this.matrix[M3x3.M11] * m.matrix[M3x3.M21] + this.matrix[M3x3.M21] * m.matrix[M3x3.M22],\n        this.matrix[M3x3.M02] * m.matrix[M3x3.M20] + this.matrix[M3x3.M12] * m.matrix[M3x3.M21] + this.matrix[M3x3.M22] * m.matrix[M3x3.M22]\n    ];\n    return output;\n}\n\n",
    "felix.20250111220451.7": "translation(x: number, y: number): M3x3 {\n    const output = new M3x3();\n    output.matrix = [\n        this.matrix[M3x3.M00],\n        this.matrix[M3x3.M01],\n        this.matrix[M3x3.M02],\n        this.matrix[M3x3.M10],\n        this.matrix[M3x3.M11],\n        this.matrix[M3x3.M12],\n\n        x * this.matrix[M3x3.M00] + y * this.matrix[M3x3.M10] + this.matrix[M3x3.M20],\n        x * this.matrix[M3x3.M01] + y * this.matrix[M3x3.M11] + this.matrix[M3x3.M21],\n        x * this.matrix[M3x3.M02] + y * this.matrix[M3x3.M12] + this.matrix[M3x3.M22]\n    ];\n    return output;\n}\n\n",
    "felix.20250111220451.8": "scale(x: number, y: number): M3x3 {\n    const output = new M3x3();\n    output.matrix = [\n        this.matrix[M3x3.M00] * x,\n        this.matrix[M3x3.M01] * x,\n        this.matrix[M3x3.M02] * x,\n\n        this.matrix[M3x3.M10] * y,\n        this.matrix[M3x3.M11] * y,\n        this.matrix[M3x3.M12] * y,\n\n        this.matrix[M3x3.M20],\n        this.matrix[M3x3.M21],\n        this.matrix[M3x3.M22]\n    ];\n    return output;\n}\n\n",
    "felix.20250111220451.9": "getFloatArray(): Float32Array {\n    return new Float32Array(this.matrix);\n}\n\n",
    "felix.20250115220303.1": "@others\n\n",
    "felix.20250115220303.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nuniform float uWorldX;\nuniform float uWorldY;\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    // uWorldX and uWorldY are factors for the x and y coordinates to convert from screen space to world space\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion by subtracting 1.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor =  vColor * texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250115220303.3": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20250115220303.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader compilation failed');\n}\n\ngl.useProgram(program);\n\n",
    "felix.20250115220303.5": "// * Start Program *\n\nconst image = await loadImage('images/plancher-vertical.png');\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);\ngl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, 128, 128, 64, 0, gl.RGBA, gl.UNSIGNED_BYTE, image); // 64 textures of 128x128 pixels\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\ngl.generateMipmap(gl.TEXTURE_2D_ARRAY);\n\nconst GameScreenX = 400;\nconst GameScreenY = 300;\n\nconst uWorldXLoc = gl.getUniformLocation(program, 'uWorldX')!;\ngl.uniform1f(uWorldXLoc, 2 / GameScreenX);\n\nconst uWorldYLoc = gl.getUniformLocation(program, 'uWorldY')!;\ngl.uniform1f(uWorldYLoc, 2 / -GameScreenY);\n\n// Create a buffer for the model data of two triangles that form a rectangle\nconst modelData = new Float32Array([\n    // XY Coords, UV Offset \n    1, 0, 1, 0,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 0,\n    0, 0, 0, 0,\n    0, 1, 0, 1,\n]);\n\n// Create a buffer for the transformation data of the three instances\n\n// Test data with posX and posY for a 400x300 resolution instead of -1 to 1.\nconst transformData = new Float32Array([\n    // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n    0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin\n    200, 150, 128, 0, 0, 1, 1,    // Blue Test at center\n    380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n]);\n\nconst modelBuffer = gl.createBuffer(); // Create a buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW); // Put data in the buffer\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0); // Describe the data in the buffer with a size of 2 because it's a 2D model, and a stride of 16 bytes because there are 4 floats per vertex in modelData.\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);\ngl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\ngl.enableVertexAttribArray(1);\ngl.vertexAttribDivisor(0, 0); // Model vertices - changes every vertex\ngl.vertexAttribDivisor(1, 0); // Texture coords - changes every vertex\n\nconst transformBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\ngl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);\ngl.vertexAttribPointer(2, 2, gl.FLOAT, false, 28, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\ngl.vertexAttribPointer(3, 1, gl.FLOAT, false, 28, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\ngl.vertexAttribPointer(4, 3, gl.FLOAT, false, 28, 12); // Describe the data in the buffer, the color (after 12 bytes of the 2 floats for x and y and the 1 float for scale)\ngl.vertexAttribPointer(5, 1, gl.FLOAT, false, 28, 24); // Describe the data in the buffer, the depth (after 24 bytes of the 2 floats for x and y and the 1 float for scale and the 3 floats for color)\n\ngl.vertexAttribDivisor(2, 1); // Tell the GPU to update the position attribute every instance\ngl.vertexAttribDivisor(3, 1); // Tell the GPU to update the scale attribute every instance\ngl.vertexAttribDivisor(4, 1); // Tell the GPU to update the color attribute every instance\ngl.vertexAttribDivisor(5, 1); // Tell the GPU to update the depth attribute every instance\n\ngl.enableVertexAttribArray(2); // Enable the attribute\ngl.enableVertexAttribArray(3); // Enable the attribute\ngl.enableVertexAttribArray(4); // Enable the attribute\ngl.enableVertexAttribArray(5); // Enable the attribute\n\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 6, 3); // Draw the model of 6 vertex that form 2 triangles, 3 times\n\n// * End Program *\n\n",
    "felix.20250116233756.1": "@others\n\n",
    "felix.20250116233756.2": "// VERTEX SHADER\nconst vertexShaderSource = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in vec2 aUV;\n\nuniform float uWorldX;\nuniform float uWorldY;\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n    // gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    // uWorldX and uWorldY are factors for the x and y coordinates to convert from screen space to world space\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion by subtracting 1.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// FRAGMENT SHADER\nconst fragmentShaderSource = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n\n",
    "felix.20250116233756.3": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20250116233756.4": "let counter = 0;\n\nfunction loop(timestamp: number): void {\n    // gl.clearColor(0.0, 0.0, 0.0, 1.0); // opaque black\n    gl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black\n\n    // Clear the canvas\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Update the posX coordinate of the first sprite\n    transformData[0] += 1;\n    if (transformData[0] > 400) {\n        transformData[0] = 0;\n    }\n\n    // Update the buffer data with the new transformData\n    gl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);\n\n    // Redraw the sprites\n    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, 3);\n\n    // Request the next frame\n    requestAnimationFrame(loop);\n\n    counter++;\n\n    if (counter % 60 == 0) {\n        console.log('Frames so far:', counter);\n    }\n}\n\nconst canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\ngl.enable(gl.BLEND);\n\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\nconst program = gl.createProgram()!;\n\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\ngl.attachShader(program, vertexShader);\n\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\ngl.attachShader(program, fragmentShader);\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    console.log(gl.getShaderInfoLog(fragmentShader));\n    console.log(gl.getProgramInfoLog(program));\n}\n\ngl.useProgram(program);\n\n",
    "felix.20250116233756.5": "// * Start Program *\n\nconst image = await loadImage('images/alien.png');\n\nconst texture = gl.createTexture()!;\ngl.bindTexture(gl.TEXTURE_2D, texture);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4096, 4096, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);\ngl.generateMipmap(gl.TEXTURE_2D);\n\nconst GameScreenX = 400;\nconst GameScreenY = 300;\n\nconst uWorldXLoc = gl.getUniformLocation(program, 'uWorldX')!;\ngl.uniform1f(uWorldXLoc, 2 / GameScreenX);\n\nconst uWorldYLoc = gl.getUniformLocation(program, 'uWorldY')!;\ngl.uniform1f(uWorldYLoc, 2 / -GameScreenY);\n\nconst modelData = new Float32Array([\n    // XY Coords, UV Offset \n    1, 0, 1, 0,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 0,\n    0, 0, 0, 0,\n    0, 1, 0, 1,\n]);\n\nconst u = (sprite: number, orientation: number) => { return ((sprite % 16) * 0.015625) + (orientation % 4) * 0.25; }\n\nconst v = (sprite: number, orientation: number) => { return (Math.floor(sprite / 16) * 0.015625) + Math.floor(orientation / 4) * 0.25; }\n\nconst transformData = new Float32Array([\n    // posX, posY, scale,  colorR, colorG, colorB, U(frame, orientation), V(frame, orientation). Usually set by game engine. 8 floats for a stride of 32 bytes.\n    0, 0, 64, 0, 1.5, 0, u(0, 0), v(0, 0),// Green Test at origin\n    200, 150, 128, 0, 0, 1, u(0, 1), v(0, 1), // Blue Test at center\n    380, 280, 32, 1, 1, 1, u(1, 1), v(1, 1),// Purple Test at bottom right\n]);\n\nconst modelBuffer = gl.createBuffer(); // Create a buffer\ngl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\ngl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW); // Put data in the buffer\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);  // XY\ngl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8); // UV Offset\ngl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\ngl.enableVertexAttribArray(1);\n\nconst transformBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\ngl.bufferData(gl.ARRAY_BUFFER, transformData, gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates\ngl.vertexAttribPointer(2, 2, gl.FLOAT, false, 32, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\ngl.vertexAttribPointer(3, 1, gl.FLOAT, false, 32, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\ngl.vertexAttribPointer(4, 3, gl.FLOAT, false, 32, 12); // Describe the data in the buffer\n\ngl.vertexAttribDivisor(2, 1); // Tell the GPU to update the position attribute every instance\ngl.vertexAttribDivisor(3, 1); // Tell the GPU to update the scale attribute every instance\ngl.vertexAttribDivisor(4, 1); // Tell the GPU to update the color attribute every instance\n\ngl.enableVertexAttribArray(2); // Enable the attribute\ngl.enableVertexAttribArray(3); // Enable the attribute\ngl.enableVertexAttribArray(4); // Enable the attribute\n\nrequestAnimationFrame(loop);\n\n// * End Program *\n",
    "felix.20250118202734.1": "@others\n\n",
    "felix.20250118202734.2": "// VERTEX SHADER\nconst SPRITE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in vec2 aUV;\n\nuniform float uWorldX;\nuniform float uWorldY;\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n    // gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    // uWorldX and uWorldY are factors for the x and y coordinates to convert from screen space to world space\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion by subtracting 1.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// FRAGMENT SHADER\nconst SPRITE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n\n",
    "felix.20250118202734.3": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20250118202734.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\ngl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black\n\nconst spriteImage = await loadImage('images/alien.png');\n\nconst spriteRenderer = new SpriteRenderer(gl, spriteImage);\nlet counter = 0;\n\nfunction loop(timestamp: number): void {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Render background tiles first\n    // tileRenderer.render(); // TODO: Implement tile renderer\n\n    // Then render sprites on top\n    spriteRenderer.render();\n\n    requestAnimationFrame(loop);\n\n    counter++;\n\n    if (counter % 60 == 0) {\n        console.log('Frames so far:', counter);\n    }\n}\n\n// Start the animation loop\nrequestAnimationFrame(loop);\n\n",
    "felix.20250118202734.6": "export abstract class BaseRenderer {\n    protected gl: WebGL2RenderingContext;\n    protected program: WebGLProgram;\n    protected vao: WebGLVertexArrayObject;\n\n    constructor(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string) {\n        this.gl = gl;\n        this.program = this.createProgram(vertexShader, fragmentShader);\n        this.gl.useProgram(this.program);\n        this.vao = this.gl.createVertexArray()!;\n    }\n\n    protected createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {\n        const program = this.gl.createProgram()!;\n        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource)!;\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource)!;\n\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n\n        return program;\n    }\n\n    protected createShader(type: number, source: string): WebGLShader {\n        const shader = this.gl.createShader(type)!;\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        return shader;\n    }\n\n    abstract render(): void;\n}\n\n",
    "felix.20250118203718.1": "export class SpriteRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement) {\n        super(gl, SPRITE_VERTEX_SHADER, SPRITE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.image = image;\n        this.texture = gl.createTexture()!;\n        this.modelBuffer = gl.createBuffer()!; // Create a buffer\n        this.transformBuffer = gl.createBuffer()!;\n\n        const u = (sprite: number, orientation: number) => { return ((sprite % 16) * 0.015625) + (orientation % 4) * 0.25; }\n        const v = (sprite: number, orientation: number) => { return (Math.floor(sprite / 16) * 0.015625) + Math.floor(orientation / 4) * 0.25; }\n        this.transformData = new Float32Array([\n            // posX, posY, scale,  colorR, colorG, colorB, U(frame, orientation), V(frame, orientation). Usually set by game engine. 8 floats for a stride of 32 bytes.\n            0, 0, 64, 0, 1.5, 0, u(0, 0), v(0, 0),// Green Test at origin\n            200, 150, 128, 0, 0, 1, u(0, 1), v(0, 1), // Blue Test at center\n            380, 280, 32, 1, 1, 1, u(1, 1), v(1, 1),// Purple Test at bottom right\n        ]);\n\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 4096, 4096, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n\n        const GameScreenX = 400;\n        const GameScreenY = 300;\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / GameScreenX);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -GameScreenY);\n\n        const modelData = new Float32Array([\n            // XY Coords, UV Offset \n            1, 0, 1, 0,\n            0, 1, 0, 1,\n            1, 1, 1, 1,\n            1, 0, 1, 0,\n            0, 0, 0, 0,\n            0, 1, 0, 1,\n        ]);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, modelData, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 16, 0);  // XY\n        this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 16, 8); // UV Offset\n        this.gl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\n        this.gl.enableVertexAttribArray(1);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates\n        this.gl.vertexAttribPointer(2, 2, this.gl.FLOAT, false, 32, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\n        this.gl.vertexAttribPointer(3, 1, this.gl.FLOAT, false, 32, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\n        this.gl.vertexAttribPointer(4, 3, this.gl.FLOAT, false, 32, 12); // Describe the data in the buffer\n\n        this.gl.vertexAttribDivisor(2, 1); // Tell the GPU to update the position attribute every instance\n        this.gl.vertexAttribDivisor(3, 1); // Tell the GPU to update the scale attribute every instance\n        this.gl.vertexAttribDivisor(4, 1); // Tell the GPU to update the color attribute every instance\n\n        this.gl.enableVertexAttribArray(2); // Enable the attribute\n        this.gl.enableVertexAttribArray(3); // Enable the attribute\n        this.gl.enableVertexAttribArray(4); // Enable the attribute\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        // Update the buffer with the new transform data and draw the sprites\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3);\n\n    }\n\n    updateTransform(index: number, x: number, y: number): void {\n        this.transformData[index * 8] = x;\n        this.transformData[index * 8 + 1] = y;\n    }\n}\n\n",
    "felix.20250119014228.1": "@others\n\n",
    "felix.20250119171554.1": "type Vec2 = { x: number, y: number };\n\ninterface GLResources {\n    buffers: WebGLBuffer[];\n    textures: WebGLTexture[];\n    shaders: WebGLShader[];\n}\n\ntype Color = {\n    r: number;\n    g: number;\n    b: number;\n};\n\ninterface RenderableSprite {\n    position: Vec2;\n    scale: number;\n    color: Color;\n    frame: number;\n    orientation: number;\n}\n\ntype SpriteUpdate = {\n    index: number;\n    properties: Partial<RenderableSprite>;\n};\n\n",
    "felix.20250119014228.2": "// BACKGROUND MAP VERTEX SHADER\nconst TILE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nuniform float uWorldX;\nuniform float uWorldY;\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// BACKGROUND MAP FRAGMENT SHADER\nconst TILE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor =  vColor * texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// ALIEN CREATURE SPRITE VERTEX SHADER\nconst SPRITE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in vec2 aUV;\n\nuniform float uWorldX;\nuniform float uWorldY;\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// ALIEN CREATURE SPRITE FRAGMENT SHADER\nconst SPRITE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\nconst MODEL_DATA = new Float32Array([\n    // XY Coords, UV Offset \n    1, 0, 1, 0,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 0,\n    0, 0, 0, 0,\n    0, 1, 0, 1,\n]);\n\nconst CONFIG = {\n    GAME_SCREEN_X: 400,\n    GAME_SCREEN_Y: 300,\n    TEXTURE_SIZE: 128,\n    TEXTURE_DEPTH: 64,\n} as const;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250119014228.3": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20250119014228.4": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\nif (!gl) {\n    throw new Error('WebGL2 not supported');\n}\n// Also check for required extensions\nif (!gl.getExtension('EXT_color_buffer_float')) {\n    throw new Error('Required WebGL extensions not supported');\n}\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\ngl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black\n\nconst tileImage = await loadImage('images/plancher-vertical.png');\n\nconst spriteImage = await loadImage('images/alien.png');\n\nconst tileRenderer = new TileRenderer(gl, tileImage);\nconst spriteRenderer = new SpriteRenderer(gl, spriteImage);\n\nwindow.addEventListener('unload', () => {\n    tileRenderer.dispose();\n    spriteRenderer.dispose();\n});\n\nlet counter = 0;\n\nfunction loop(timestamp: number): void {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Render background tiles first\n    tileRenderer.render();\n\n    // Update the sprite position every frame demonstrating the dynamic nature of the sprite renderer\n    spriteRenderer.updateSprites([{\n        index: 0,\n        properties: {\n            position: {\n                x: Math.sin(timestamp / 1000) * 100 + 100,\n                y: Math.cos(timestamp / 1000) * 100 + 100\n            }\n        }\n    }]);\n\n    // Then render sprites on top\n    spriteRenderer.render();\n\n    requestAnimationFrame(loop);\n\n    // Console output just to make sure this is running.\n    counter++;\n    if (counter % 60 == 0) {\n        console.log('Frames so far:', counter);\n    }\n}\n\n// Start the animation loop\nrequestAnimationFrame(loop);\n\n",
    "felix.20250119014228.5": "abstract class BaseRenderer {\n    protected gl: WebGL2RenderingContext;\n    protected program: WebGLProgram;\n    protected vao: WebGLVertexArrayObject;\n    protected resources: GLResources = {\n        buffers: [],\n        textures: [],\n        shaders: []\n    };\n\n    constructor(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string) {\n        this.gl = gl;\n        this.program = this.createProgram(vertexShader, fragmentShader);\n        this.gl.useProgram(this.program);\n        this.vao = this.gl.createVertexArray()!;\n    }\n\n    protected createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {\n        const program = this.gl.createProgram()!;\n        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource)!;\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource)!;\n\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n\n        return program;\n    }\n\n    protected createShader(type: number, source: string): WebGLShader {\n        const shader = this.gl.createShader(type)!;\n        this.resources.shaders.push(shader);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n            throw new Error('Shader compilation failed');\n        }\n        return shader;\n    }\n\n    protected createBuffer(): WebGLBuffer {\n        const buffer = this.gl.createBuffer()!;\n        this.resources.buffers.push(buffer);\n        return buffer;\n    }\n\n    protected createTexture(): WebGLTexture {\n        const texture = this.gl.createTexture()!;\n        this.resources.textures.push(texture);\n        return texture;\n    }\n\n    abstract render(): void;\n    dispose(): void {\n        // Delete all resources in reverse order\n        this.resources.textures.forEach(texture => this.gl.deleteTexture(texture));\n        this.resources.buffers.forEach(buffer => this.gl.deleteBuffer(buffer));\n        this.resources.shaders.forEach(shader => this.gl.deleteShader(shader));\n        this.gl.deleteProgram(this.program);\n        this.gl.deleteVertexArray(this.vao);\n\n        // Clear arrays\n        this.resources.textures = [];\n        this.resources.buffers = [];\n        this.resources.shaders = [];\n    }\n}\n\n",
    "felix.20250119014352.1": "class TileRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement) {\n        super(gl, TILE_VERTEX_SHADER, TILE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        this.transformData = new Float32Array([\n            // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n            0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin\n            200, 150, 128, 0, 0, 1, 1,    // Blue Test at center\n            380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n        ]);\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.TEXTURE_SIZE, CONFIG.TEXTURE_SIZE, CONFIG.TEXTURE_DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image); // 64 textures of 128x128 pixels\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / CONFIG.GAME_SCREEN_X);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -CONFIG.GAME_SCREEN_Y);\n\n        // Create a buffer for the transformation data of the three instances\n        // Test data with posX and posY for a 400x300 resolution instead of -1 to 1.\n        this.transformData = new Float32Array([\n            // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n            0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin\n            200, 150, 128, 0, 0, 1, 1,    // Blue Test at center\n            380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n        ]);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 16, 0); // Describe the data in the buffer with a size of 2 because it's a 2D model, and a stride of 16 bytes because there are 4 floats per vertex in MODEL_DATA.\n        this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 16, 8);\n        this.gl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\n        this.gl.enableVertexAttribArray(1);\n        this.gl.vertexAttribDivisor(0, 0); // Model vertices - changes every vertex\n        this.gl.vertexAttribDivisor(1, 0); // Texture coords - changes every vertex\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);\n        this.gl.vertexAttribPointer(2, 2, this.gl.FLOAT, false, 28, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\n        this.gl.vertexAttribPointer(3, 1, this.gl.FLOAT, false, 28, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\n        this.gl.vertexAttribPointer(4, 3, this.gl.FLOAT, false, 28, 12); // Describe the data in the buffer, the color (after 12 bytes of the 2 floats for x and y and the 1 float for scale)\n        this.gl.vertexAttribPointer(5, 1, this.gl.FLOAT, false, 28, 24); // Describe the data in the buffer, the depth (after 24 bytes of the 2 floats for x and y and the 1 float for scale and the 3 floats for color)\n\n        this.gl.vertexAttribDivisor(2, 1); // Tell the GPU to update the position attribute every instance\n        this.gl.vertexAttribDivisor(3, 1); // Tell the GPU to update the scale attribute every instance\n        this.gl.vertexAttribDivisor(4, 1); // Tell the GPU to update the color attribute every instance\n        this.gl.vertexAttribDivisor(5, 1); // Tell the GPU to update the depth attribute every instance\n\n        this.gl.enableVertexAttribArray(2); // Enable the attribute\n        this.gl.enableVertexAttribArray(3); // Enable the attribute\n        this.gl.enableVertexAttribArray(4); // Enable the attribute\n        this.gl.enableVertexAttribArray(5); // Enable the attribute\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        // Update the buffer with the new transform data and draw the sprites\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3); // Draw the model of 6 vertex that form 2 triangles, 3 times\n\n    }\n\n}\n\n",
    "felix.20250119014228.6": "class SpriteRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private dirtyTransforms = false;\n    private sprites: RenderableSprite[];\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement) {\n        super(gl, SPRITE_VERTEX_SHADER, SPRITE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.image = image;\n        this.texture = this.createTexture()!;\n        this.modelBuffer = this.createBuffer()!; // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n        this.transformData = new Float32Array(24); // 8 floats per sprite\n\n        this.sprites = [\n            { position: { x: 0, y: 0 }, scale: 64, color: { r: 0, g: 1.5, b: 0 }, frame: 0, orientation: 0 },\n            { position: { x: 200, y: 150 }, scale: 128, color: { r: 0, g: 0, b: 1 }, frame: 22, orientation: 4 },\n            { position: { x: 380, y: 280 }, scale: 32, color: { r: 1, g: 1, b: 1 }, frame: 33, orientation: 7 }\n        ];\n\n        this.updateTransformData();\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 4096, 4096, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / CONFIG.GAME_SCREEN_X);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -CONFIG.GAME_SCREEN_Y);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.gl.vertexAttribPointer(0, 2, this.gl.FLOAT, false, 16, 0);  // XY\n        this.gl.vertexAttribPointer(1, 2, this.gl.FLOAT, false, 16, 8); // UV Offset\n        this.gl.enableVertexAttribArray(0); // Enable the attribute which is bound to the buffer\n        this.gl.enableVertexAttribArray(1);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates\n        this.gl.vertexAttribPointer(2, 2, this.gl.FLOAT, false, 32, 0); // Describe the data in the buffer: the x and y coordinates after no offset.\n        this.gl.vertexAttribPointer(3, 1, this.gl.FLOAT, false, 32, 8); // Describe the data in the buffer, the scale (after the 8 bytes of the 2 floats for x and y)\n        this.gl.vertexAttribPointer(4, 3, this.gl.FLOAT, false, 32, 12); // Describe the data in the buffer\n\n        this.gl.vertexAttribDivisor(2, 1); // Tell the GPU to update the position attribute every instance\n        this.gl.vertexAttribDivisor(3, 1); // Tell the GPU to update the scale attribute every instance\n        this.gl.vertexAttribDivisor(4, 1); // Tell the GPU to update the color attribute every instance\n\n        this.gl.enableVertexAttribArray(2); // Enable the attribute\n        this.gl.enableVertexAttribArray(3); // Enable the attribute\n        this.gl.enableVertexAttribArray(4); // Enable the attribute\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        // Update the buffer with the new transform data and draw the sprites\n        if (this.dirtyTransforms) {\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3);\n\n    }\n\n    private updateTransformData(): void {\n        const u = (sprite: number, orientation: number) => ((sprite % 16) * 0.015625) + (orientation % 4) * 0.25;\n        const v = (sprite: number, orientation: number) => (Math.floor(sprite / 16) * 0.015625) + Math.floor(orientation / 4) * 0.25;\n\n        this.sprites.forEach((sprite, i) => {\n            const offset = i * 8;\n            this.transformData[offset] = sprite.position.x;\n            this.transformData[offset + 1] = sprite.position.y;\n            this.transformData[offset + 2] = sprite.scale;\n            this.transformData[offset + 3] = sprite.color.r;\n            this.transformData[offset + 4] = sprite.color.g;\n            this.transformData[offset + 5] = sprite.color.b;\n            this.transformData[offset + 6] = u(sprite.frame, sprite.orientation);\n            this.transformData[offset + 7] = v(sprite.frame, sprite.orientation);\n        });\n        this.dirtyTransforms = true;\n    }\n\n    updateSprites(updates: SpriteUpdate[]): void {\n        updates.forEach(({ index, properties }) => {\n            this.sprites[index] = { ...this.sprites[index], ...properties };\n        });\n        this.updateTransformData();\n    }\n\n}\n\n",
    "felix.20250119210437.1": "@others\n\n",
    "felix.20250119210437.2": "type Vec2 = { x: number, y: number };\n\ninterface GLResources {\n    buffers: WebGLBuffer[];\n    textures: WebGLTexture[];\n    shaders: WebGLShader[];\n}\n\ntype Color = {\n    r: number;\n    g: number;\n    b: number;\n};\n\ninterface RenderableSprite {\n    position: Vec2;\n    scale: number;\n    color: Color;\n    frame: number;\n    orientation: number;\n}\n\ntype SpriteUpdate = {\n    index: number;\n    properties: Partial<RenderableSprite>;\n};\n\nenum ShaderAttribute {\n    POSITION = 0,\n    TEXCOORD = 1,\n    OFFSET = 2,\n    SCALE = 3,\n    COLOR = 4,\n    DEPTH = 5,\n    UV = 5\n}\n\nenum ShaderType {\n    VERTEX = WebGL2RenderingContext.VERTEX_SHADER,\n    FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER\n}\n\ntype WebGLError = {\n    type: 'shader' | 'program' | 'buffer' | 'texture';\n    message: string;\n    details?: string;\n}\n\n",
    "felix.20250119210437.3": "// BACKGROUND MAP VERTEX SHADER\nconst TILE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// BACKGROUND MAP FRAGMENT SHADER\nconst TILE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor =  vColor * texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// ALIEN CREATURE SPRITE VERTEX SHADER\nconst SPRITE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in vec2 aUV;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// ALIEN CREATURE SPRITE FRAGMENT SHADER\nconst SPRITE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\nconst MODEL_DATA = new Float32Array([\n    // XY Coords, UV Offset \n    1, 0, 1, 0,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 0,\n    0, 0, 0, 0,\n    0, 1, 0, 1,\n]);\n\nconst CONFIG = {\n    GAME_SCREEN_X: 400,\n    GAME_SCREEN_Y: 300,\n    TEXTURE_SIZE: 128,\n    TEXTURE_DEPTH: 64,\n    ATTRIBUTES: {\n        POSITION_SIZE: 2,\n        TEXCOORD_SIZE: 2,\n        OFFSET_SIZE: 2,\n        SCALE_SIZE: 1,\n        COLOR_SIZE: 3,\n        DEPTH_SIZE: 1\n    }\n} as const;\n\nconst SPRITE_SHEET = {\n    SPRITES_PER_ROW: 16,\n    ORIENTATIONS_PER_ROW: 4,\n    UV_UNIT: 0.015625 // (1/64) Pre-calculated\n} as const;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250119210437.4": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20250119210437.5": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\nif (!gl) {\n    throw new Error('WebGL2 not supported');\n}\n// Also check for required extensions\nif (!gl.getExtension('EXT_color_buffer_float')) {\n    throw new Error('Required WebGL extensions not supported');\n}\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\ngl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black\n\nconst tileImage = await loadImage('images/plancher-vertical.png');\n\nconst spriteImage = await loadImage('images/alien.png');\n\nconst tileRenderer = new TileRenderer(gl, tileImage);\nconst spriteRenderer = new SpriteRenderer(gl, spriteImage);\n\n// Create a uniform buffer\nconst worldBuffer = gl.createBuffer();\ngl.bindBuffer(gl.UNIFORM_BUFFER, worldBuffer);\ngl.bufferData(gl.UNIFORM_BUFFER, 2 * Float32Array.BYTES_PER_ELEMENT, gl.DYNAMIC_DRAW);\n\n// Bind the buffer to binding point 0\ngl.bindBufferBase(gl.UNIFORM_BUFFER, 0, worldBuffer);\n\n// Set the uniform block binding for both programs\nconst tileProgram = tileRenderer.program;\nconst spriteProgram = spriteRenderer.program;\nconst worldIndex = 0; // Binding point 0\n\nconst tileBlockIndex = gl.getUniformBlockIndex(tileProgram, 'World');\ngl.uniformBlockBinding(tileProgram, tileBlockIndex, worldIndex);\n\nconst spriteBlockIndex = gl.getUniformBlockIndex(spriteProgram, 'World');\ngl.uniformBlockBinding(spriteProgram, spriteBlockIndex, worldIndex);\n\nwindow.addEventListener('unload', () => {\n    tileRenderer.dispose();\n    spriteRenderer.dispose();\n});\n\nlet counter = 0;\n\nfunction loop(timestamp: number): void {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Update the uniform buffer with the new values along with a small variation demonstrating the UBO is working.\n    const uboVariation = Math.sin(timestamp / 2000) * 100; // This will vary from -100 to 100\n    const worldData = new Float32Array([2 / (CONFIG.GAME_SCREEN_X + uboVariation), 2 / -(CONFIG.GAME_SCREEN_Y + uboVariation)]);\n    gl.bindBuffer(gl.UNIFORM_BUFFER, worldBuffer);\n    gl.bufferSubData(gl.UNIFORM_BUFFER, 0, worldData);\n\n    // Render background tiles first\n    tileRenderer.render();\n\n    // Update the sprite position every frame demonstrating the dynamic nature of the sprite renderer\n    spriteRenderer.updateSprites([{\n        index: 0,\n        properties: {\n            position: {\n                x: Math.sin(timestamp / 1000) * 100 + 100,\n                y: Math.cos(timestamp / 1000) * 100 + 100\n            }\n        }\n    }]);\n\n    // Then render sprites on top\n    spriteRenderer.render();\n\n    requestAnimationFrame(loop);\n\n    // Console output just to make sure this is running.\n    counter++;\n    if (counter % 60 == 0) {\n        console.log('Frames so far:', counter);\n    }\n}\n\n// Start the animation loop\nrequestAnimationFrame(loop);\n\n",
    "felix.20250119210437.6": "abstract class BaseRenderer {\n    protected gl: WebGL2RenderingContext;\n    public program: WebGLProgram;\n    protected vao: WebGLVertexArrayObject;\n    protected resources: GLResources = {\n        buffers: [],\n        textures: [],\n        shaders: []\n    };\n\n    constructor(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string) {\n        this.gl = gl;\n        this.program = this.createProgram(vertexShader, fragmentShader);\n        this.gl.useProgram(this.program);\n        this.vao = this.gl.createVertexArray()!;\n    }\n\n    protected createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {\n        const program = this.gl.createProgram()!;\n        let errorLog = '';\n        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource)!;\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource)!;\n\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n\n        // Check linking status\n        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n            errorLog += `\\nProgram linking failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n\n        // Validate program\n        this.gl.validateProgram(program);\n        if (!this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS)) {\n            errorLog += `\\nProgram validation failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n\n        // Check if program can run in current WebGL state\n        const activeAttributes = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);\n        const activeUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n\n        if (activeAttributes === 0 && activeUniforms === 0) {\n            errorLog += '\\nWarning: Program has no active attributes or uniforms';\n        }\n\n        if (errorLog) {\n            throw new Error(`WebGL Program creation failed: ${errorLog}`);\n        }\n\n        return program;\n    }\n\n    protected createShader(type: ShaderType, source: string): WebGLShader {\n        const shader = this.gl.createShader(type)!;\n        this.resources.shaders.push(shader);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n            throw new Error('Shader compilation failed');\n        }\n        return shader;\n    }\n\n    protected createBuffer(): WebGLBuffer {\n        const buffer = this.gl.createBuffer()!;\n        this.resources.buffers.push(buffer);\n        return buffer;\n    }\n\n    protected createTexture(): WebGLTexture {\n        const texture = this.gl.createTexture()!;\n        this.resources.textures.push(texture);\n        return texture;\n    }\n\n    protected setupAttribute(\n        location: ShaderAttribute,\n        size: number,\n        stride: number,\n        offset: number,\n        divisor: number = 0\n    ): void {\n        this.gl.vertexAttribPointer(location, size, this.gl.FLOAT, false, stride, offset);\n        this.gl.enableVertexAttribArray(location);\n        this.gl.vertexAttribDivisor(location, divisor);\n    }\n\n    abstract render(): void;\n    dispose(): void {\n        // Delete all resources in reverse order\n        this.resources.textures.forEach(texture => this.gl.deleteTexture(texture));\n        this.resources.buffers.forEach(buffer => this.gl.deleteBuffer(buffer));\n        this.resources.shaders.forEach(shader => this.gl.deleteShader(shader));\n        this.gl.deleteProgram(this.program);\n        this.gl.deleteVertexArray(this.vao);\n\n        // Clear arrays\n        this.resources.textures = [];\n        this.resources.buffers = [];\n        this.resources.shaders = [];\n    }\n}\n\n",
    "felix.20250119210437.7": "class TileRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement) {\n        super(gl, TILE_VERTEX_SHADER, TILE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        this.transformData = new Float32Array([\n            // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n            0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin\n            200, 150, 128, 0, 0, 1, 1,    // Blue Test at center\n            380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n        ]);\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.TEXTURE_SIZE, CONFIG.TEXTURE_SIZE, CONFIG.TEXTURE_DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image); // 64 textures of 128x128 pixels\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / CONFIG.GAME_SCREEN_X);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -CONFIG.GAME_SCREEN_Y);\n\n        // Create a buffer for the transformation data of the three instances\n        // Test data with posX and posY for a 400x300 resolution instead of -1 to 1.\n        this.transformData = new Float32Array([\n            // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n            0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin\n            200, 150, 128, 0, 0, 1, 1,    // Blue Test at center\n            380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n        ]);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.setupAttribute(ShaderAttribute.POSITION, CONFIG.ATTRIBUTES.POSITION_SIZE, 16, 0);\n        this.setupAttribute(ShaderAttribute.TEXCOORD, CONFIG.ATTRIBUTES.TEXCOORD_SIZE, 16, 8);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);\n        this.setupAttribute(ShaderAttribute.OFFSET, CONFIG.ATTRIBUTES.OFFSET_SIZE, 28, 0, 1);\n        this.setupAttribute(ShaderAttribute.SCALE, CONFIG.ATTRIBUTES.SCALE_SIZE, 28, 8, 1);\n        this.setupAttribute(ShaderAttribute.COLOR, CONFIG.ATTRIBUTES.COLOR_SIZE, 28, 12, 1);\n        this.setupAttribute(ShaderAttribute.DEPTH, CONFIG.ATTRIBUTES.DEPTH_SIZE, 28, 24, 1);\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        // Update the buffer with the new transform data and draw the sprites\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3); // Draw the model of 6 vertex that form 2 triangles, 3 times\n\n    }\n\n}\n\n",
    "felix.20250119210437.8": "class SpriteRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private dirtyTransforms = false;\n    private sprites: RenderableSprite[];\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement) {\n        super(gl, SPRITE_VERTEX_SHADER, SPRITE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.image = image;\n        this.texture = this.createTexture()!;\n        this.modelBuffer = this.createBuffer()!; // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n        this.transformData = new Float32Array(24); // 8 floats per sprite\n\n        this.sprites = [\n            { position: { x: 0, y: 0 }, scale: 64, color: { r: 0, g: 1.5, b: 0 }, frame: 0, orientation: 0 },\n            { position: { x: 200, y: 150 }, scale: 128, color: { r: 0, g: 0, b: 1 }, frame: 22, orientation: 4 },\n            { position: { x: 380, y: 280 }, scale: 32, color: { r: 1, g: 1, b: 1 }, frame: 33, orientation: 7 }\n        ];\n\n        this.updateTransformData();\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 4096, 4096, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / CONFIG.GAME_SCREEN_X);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -CONFIG.GAME_SCREEN_Y);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.setupAttribute(ShaderAttribute.POSITION, CONFIG.ATTRIBUTES.POSITION_SIZE, 16, 0);\n        this.setupAttribute(ShaderAttribute.TEXCOORD, CONFIG.ATTRIBUTES.TEXCOORD_SIZE, 16, 8);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates\n        this.setupAttribute(ShaderAttribute.OFFSET, CONFIG.ATTRIBUTES.OFFSET_SIZE, 32, 0, 1);\n        this.setupAttribute(ShaderAttribute.SCALE, CONFIG.ATTRIBUTES.SCALE_SIZE, 32, 8, 1);\n        this.setupAttribute(ShaderAttribute.COLOR, CONFIG.ATTRIBUTES.COLOR_SIZE, 32, 12, 1);\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        // Update the buffer with the new transform data and draw the sprites\n        if (this.dirtyTransforms) {\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3);\n\n    }\n\n    private updateTransformData(): void {\n        const u = (sprite: number, orientation: number) => ((sprite % SPRITE_SHEET.SPRITES_PER_ROW) * SPRITE_SHEET.UV_UNIT) + (orientation % SPRITE_SHEET.ORIENTATIONS_PER_ROW) * 0.25;\n        const v = (sprite: number, orientation: number) => (Math.floor(sprite / SPRITE_SHEET.SPRITES_PER_ROW) * SPRITE_SHEET.UV_UNIT) + Math.floor(orientation / SPRITE_SHEET.ORIENTATIONS_PER_ROW) * 0.25;\n\n        this.sprites.forEach((sprite, i) => {\n            const offset = i * 8;\n            this.transformData[offset] = sprite.position.x;\n            this.transformData[offset + 1] = sprite.position.y;\n            this.transformData[offset + 2] = sprite.scale;\n            this.transformData[offset + 3] = sprite.color.r;\n            this.transformData[offset + 4] = sprite.color.g;\n            this.transformData[offset + 5] = sprite.color.b;\n            this.transformData[offset + 6] = u(sprite.frame, sprite.orientation);\n            this.transformData[offset + 7] = v(sprite.frame, sprite.orientation);\n        });\n        this.dirtyTransforms = true;\n    }\n\n    updateSprites(updates: SpriteUpdate[]): void {\n        updates.forEach(({ index, properties }) => {\n            this.sprites[index] = { ...this.sprites[index], ...properties };\n        });\n        this.updateTransformData();\n    }\n\n}\n\n",
    "felix.20250121223733.1": "@others\n",
    "felix.20250121223733.2": "type Vec2 = { x: number, y: number };\n\ninterface GLResources {\n    buffers: WebGLBuffer[];\n    textures: WebGLTexture[];\n    shaders: WebGLShader[];\n}\n\ntype Color = {\n    r: number;\n    g: number;\n    b: number;\n};\n\ninterface RenderableSprite {\n    position: Vec2;\n    scale: number;\n    color: Color;\n    frame: number;\n    orientation: number;\n}\n\ntype SpriteUpdate = {\n    index: number;\n    properties: Partial<RenderableSprite>;\n};\n\nenum ShaderType {\n    VERTEX = WebGL2RenderingContext.VERTEX_SHADER,\n    FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER\n}\n\ntype WebGLError = {\n    type: 'shader' | 'program' | 'buffer' | 'texture';\n    message: string;\n    details?: string;\n}\n\n",
    "felix.20250121223733.3": "// BACKGROUND MAP VERTEX SHADER\nconst TILE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// BACKGROUND MAP FRAGMENT SHADER\nconst TILE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor =  vColor * texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// ALIEN CREATURE SPRITE VERTEX SHADER\nconst SPRITE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in vec2 aUV;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// ALIEN CREATURE SPRITE FRAGMENT SHADER\nconst SPRITE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\n// SELECTION LINE VERTEX SHADER\nconst RECTANGLE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScaleX;\nlayout(location=3) in float aScaleY;\nlayout(location=4) in vec4 aColor;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    vec3 pos = aPosition.xyz * vec3(aScaleX, aScaleY, 1.0) + aOffset;\n    \n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// SELECTION LINE SPRITE FRAGMENT SHADER\nconst RECTANGLE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor;\n}`;\n\nconst MODEL_DATA = new Float32Array([\n    // XY Coords, UV Offset \n    1, 0, 1, 0,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 0,\n    0, 0, 0, 0,\n    0, 1, 0, 1,\n]);\n\nconst RECTANGLE_MODEL_DATA = new Float32Array([\n    // XY Coords\n    1, 0,\n    0, 1,\n    1, 1,\n    1, 0,\n    0, 0,\n    0, 1,\n]);\n\nconst CONFIG = {\n    GAME_SCREEN_X: 400,\n    GAME_SCREEN_Y: 300,\n    TEXTURE_SIZE: 128,\n    TEXTURE_DEPTH: 64,\n    ATTRIBUTES: {\n        POSITION_SIZE: 2,\n        TEXCOORD_SIZE: 2,\n        OFFSET_SIZE: 2,\n        SCALE_SIZE: 1,\n        COLOR_SIZE: 3,\n        DEPTH_SIZE: 1\n    }\n} as const;\n\nconst SPRITE_SHEET = {\n    SPRITES_PER_ROW: 16,\n    ORIENTATIONS_PER_ROW: 4,\n    UV_UNIT: 0.015625 // (1/64) Pre-calculated\n} as const;\n\n// Load image asynchronously\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250121223733.4": "(async () => {\n\n    @others\n\n})();\n\n",
    "felix.20250121223733.5": "const canvas = document.querySelector('canvas')!;\nconst gl = canvas.getContext('webgl2')!;\n\nif (!gl) {\n    throw new Error('WebGL2 not supported');\n}\nif (!gl.getExtension('EXT_color_buffer_float')) {\n    throw new Error('Required WebGL extensions not supported');\n}\n\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\ngl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black\n\nconst tileImage = await loadImage('images/plancher-vertical.png');\nconst spriteImage = await loadImage('images/alien.png');\n\nconst tileRenderer = new TileRenderer(gl, tileImage);\nconst spriteRenderer = new SpriteRenderer(gl, spriteImage);\nconst lineRenderer = new RectangleRenderer(gl);\n\n// Create a uniform buffer\nconst worldBuffer = gl.createBuffer();\ngl.bindBuffer(gl.UNIFORM_BUFFER, worldBuffer);\ngl.bufferData(gl.UNIFORM_BUFFER, 2 * Float32Array.BYTES_PER_ELEMENT, gl.DYNAMIC_DRAW);\n\n// Bind the buffer to binding point 0\ngl.bindBufferBase(gl.UNIFORM_BUFFER, 0, worldBuffer);\n\n// Set the uniform block binding for both programs\nconst tileProgram = tileRenderer.program;\nconst spriteProgram = spriteRenderer.program;\nconst lineProgram = lineRenderer.program;\nconst worldIndex = 0; // Binding point 0\n\nconst tileBlockIndex = gl.getUniformBlockIndex(tileProgram, 'World');\ngl.uniformBlockBinding(tileProgram, tileBlockIndex, worldIndex);\n\nconst spriteBlockIndex = gl.getUniformBlockIndex(spriteProgram, 'World');\ngl.uniformBlockBinding(spriteProgram, spriteBlockIndex, worldIndex);\n\nconst lineBlockIndex = gl.getUniformBlockIndex(lineProgram, 'World');\ngl.uniformBlockBinding(lineProgram, lineBlockIndex, worldIndex);\n\nwindow.addEventListener('unload', () => {\n    tileRenderer.dispose();\n    spriteRenderer.dispose();\n    // lineRenderer.dispose();\n});\n\nlet counter = 0;\n\nfunction loop(timestamp: number): void {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Update the uniform buffer with the new values along with a small variation demonstrating the UBO is working.\n    const uboVariation = Math.sin(timestamp / 2000) * 100; // This will vary from -100 to 100\n    const worldData = new Float32Array([2 / (CONFIG.GAME_SCREEN_X + uboVariation), 2 / -(CONFIG.GAME_SCREEN_Y + uboVariation)]);\n    gl.bindBuffer(gl.UNIFORM_BUFFER, worldBuffer);\n    gl.bufferSubData(gl.UNIFORM_BUFFER, 0, worldData);\n\n    tileRenderer.render(); // background tiles first...\n    spriteRenderer.updateSprites([{\n        index: 0,\n        properties: {\n            position: {\n                x: Math.sin(timestamp / 1000) * 100 + 100,\n                y: Math.cos(timestamp / 1000) * 100 + 100\n            }\n        }\n    }]);\n    spriteRenderer.render(); // Then sprites, with changing positions demonstrating the dynamic nature of the sprite renderer\n    lineRenderer.render(); // Selection lines last.\n\n    requestAnimationFrame(loop);\n\n    // Console output just to make sure this is running.\n    counter++;\n    if (counter % 60 == 0) {\n        console.log('Frames so far:', counter);\n    }\n}\n\nrequestAnimationFrame(loop); // Start the loop\n",
    "felix.20250121223733.6": "abstract class BaseRenderer {\n    protected gl: WebGL2RenderingContext;\n    public program: WebGLProgram;\n    protected vao: WebGLVertexArrayObject;\n    protected resources: GLResources = {\n        buffers: [],\n        textures: [],\n        shaders: []\n    };\n\n    constructor(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string) {\n        this.gl = gl;\n        this.program = this.createProgram(vertexShader, fragmentShader);\n        this.gl.useProgram(this.program);\n        this.vao = this.gl.createVertexArray()!;\n    }\n\n    protected createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {\n        const program = this.gl.createProgram()!;\n        let errorLog = '';\n        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource)!;\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource)!;\n\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n\n        // Error checking\n        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n            errorLog += `\\nProgram linking failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n        this.gl.validateProgram(program);\n        if (!this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS)) {\n            errorLog += `\\nProgram validation failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n        const activeAttributes = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);\n        const activeUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n        if (activeAttributes === 0 && activeUniforms === 0) {\n            errorLog += '\\nWarning: Program has no active attributes or uniforms';\n        }\n        if (errorLog) {\n            throw new Error(`WebGL Program creation failed: ${errorLog}`);\n        }\n\n        return program;\n    }\n\n    protected createShader(type: ShaderType, source: string): WebGLShader {\n        const shader = this.gl.createShader(type)!;\n        this.resources.shaders.push(shader);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n            throw new Error('Shader compilation failed');\n        }\n        return shader;\n    }\n\n    protected createBuffer(): WebGLBuffer {\n        const buffer = this.gl.createBuffer()!;\n        this.resources.buffers.push(buffer);\n        return buffer;\n    }\n\n    protected createTexture(): WebGLTexture {\n        const texture = this.gl.createTexture()!;\n        this.resources.textures.push(texture);\n        return texture;\n    }\n\n    protected setupAttribute(\n        location: number,\n        size: number,\n        stride: number,\n        offset: number,\n        divisor: number = 0\n    ): void {\n        this.gl.vertexAttribPointer(location, size, this.gl.FLOAT, false, stride, offset);\n        this.gl.enableVertexAttribArray(location);\n        this.gl.vertexAttribDivisor(location, divisor);\n    }\n\n    abstract render(): void;\n    dispose(): void {\n        // Delete all resources in reverse order\n        this.resources.textures.forEach(texture => this.gl.deleteTexture(texture));\n        this.resources.buffers.forEach(buffer => this.gl.deleteBuffer(buffer));\n        this.resources.shaders.forEach(shader => this.gl.deleteShader(shader));\n        this.gl.deleteProgram(this.program);\n        this.gl.deleteVertexArray(this.vao);\n\n        // Clear arrays\n        this.resources.textures = [];\n        this.resources.buffers = [];\n        this.resources.shaders = [];\n    }\n}\n\n",
    "felix.20250121223733.7": "class TileRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement) {\n        super(gl, TILE_VERTEX_SHADER, TILE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        this.transformData = new Float32Array([\n            // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n            0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin\n            200, 150, 128, 0, 0, 1, 1,    // Blue Test at center\n            380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n        ]);\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.TEXTURE_SIZE, CONFIG.TEXTURE_SIZE, CONFIG.TEXTURE_DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image); // 64 textures of 128x128 pixels\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / CONFIG.GAME_SCREEN_X);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -CONFIG.GAME_SCREEN_Y);\n\n        // Create a buffer for the transformation data of the three instances\n        // Test data with posX and posY for a 400x300 resolution instead of -1 to 1.\n        this.transformData = new Float32Array([\n            // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n            0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin\n            300, 200, 128, 0, 0, 1, 1,    // Blue Test at center\n            380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right\n        ]);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.setupAttribute(0, CONFIG.ATTRIBUTES.POSITION_SIZE, 16, 0);\n        this.setupAttribute(1, CONFIG.ATTRIBUTES.TEXCOORD_SIZE, 16, 8);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates);\n        this.setupAttribute(2, CONFIG.ATTRIBUTES.OFFSET_SIZE, 28, 0, 1);\n        this.setupAttribute(3, CONFIG.ATTRIBUTES.SCALE_SIZE, 28, 8, 1);\n        this.setupAttribute(4, CONFIG.ATTRIBUTES.COLOR_SIZE, 28, 12, 1);\n        this.setupAttribute(5, CONFIG.ATTRIBUTES.DEPTH_SIZE, 28, 24, 1);\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        // Update the buffer with the new transform data and draw the sprites\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3); // Draw the model of 6 vertex that form 2 triangles, 3 times\n\n    }\n\n}\n\n",
    "felix.20250121223733.8": "class SpriteRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private dirtyTransforms = false;\n    private sprites: RenderableSprite[];\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement) {\n        super(gl, SPRITE_VERTEX_SHADER, SPRITE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.image = image;\n        this.texture = this.createTexture()!;\n        this.modelBuffer = this.createBuffer()!; // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n        this.transformData = new Float32Array(24); // 8 floats per sprite\n\n        this.sprites = [\n            { position: { x: 0, y: 0 }, scale: 64, color: { r: 0, g: 1.5, b: 0 }, frame: 0, orientation: 0 },\n            { position: { x: 200, y: 150 }, scale: 128, color: { r: 0, g: 0, b: 1 }, frame: 22, orientation: 4 },\n            { position: { x: 380, y: 280 }, scale: 32, color: { r: 1, g: 1, b: 1 }, frame: 33, orientation: 7 }\n        ];\n\n        this.updateTransformData();\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 4096, 4096, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / CONFIG.GAME_SCREEN_X);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -CONFIG.GAME_SCREEN_Y);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.setupAttribute(0, CONFIG.ATTRIBUTES.POSITION_SIZE, 16, 0);\n        this.setupAttribute(1, CONFIG.ATTRIBUTES.TEXCOORD_SIZE, 16, 8);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates\n        this.setupAttribute(2, CONFIG.ATTRIBUTES.OFFSET_SIZE, 32, 0, 1);\n        this.setupAttribute(3, CONFIG.ATTRIBUTES.SCALE_SIZE, 32, 8, 1);\n        this.setupAttribute(4, CONFIG.ATTRIBUTES.COLOR_SIZE, 32, 12, 1);\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        // Update the buffer with the new transform data and draw the sprites\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Need to bind the buffer before updating it because it was unbound after the VAO was unbound\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3);\n\n    }\n\n    private updateTransformData(): void {\n        const u = (sprite: number, orientation: number) => ((sprite % SPRITE_SHEET.SPRITES_PER_ROW) * SPRITE_SHEET.UV_UNIT) + (orientation % SPRITE_SHEET.ORIENTATIONS_PER_ROW) * 0.25;\n        const v = (sprite: number, orientation: number) => (Math.floor(sprite / SPRITE_SHEET.SPRITES_PER_ROW) * SPRITE_SHEET.UV_UNIT) + Math.floor(orientation / SPRITE_SHEET.ORIENTATIONS_PER_ROW) * 0.25;\n\n        this.sprites.forEach((sprite, i) => {\n            const offset = i * 8;\n            this.transformData[offset] = sprite.position.x;\n            this.transformData[offset + 1] = sprite.position.y;\n            this.transformData[offset + 2] = sprite.scale;\n            this.transformData[offset + 3] = sprite.color.r;\n            this.transformData[offset + 4] = sprite.color.g;\n            this.transformData[offset + 5] = sprite.color.b;\n            this.transformData[offset + 6] = u(sprite.frame, sprite.orientation);\n            this.transformData[offset + 7] = v(sprite.frame, sprite.orientation);\n        });\n        this.dirtyTransforms = true;\n    }\n\n    updateSprites(updates: SpriteUpdate[]): void {\n        updates.forEach(({ index, properties }) => {\n            this.sprites[index] = { ...this.sprites[index], ...properties };\n        });\n        this.updateTransformData();\n    }\n\n}\n\n",
    "felix.20250121225028.1": "class RectangleRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n\n    constructor(gl: WebGL2RenderingContext) {\n        super(gl, RECTANGLE_VERTEX_SHADER, RECTANGLE_FRAGMENT_SHADER);\n        // Move existing shader setup & buffer creation here\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        this.transformData = new Float32Array([\n            // posX, posY, scaleX, scaleY, colorR, colorG, colorB. A stride of 28 bytes.\n            20, 20, 64, 2, 0, 1, 0,       // Green Test at origin\n            150, 100, 2, 32, 0, 1, 0,    // Blue Test at center\n            280, 180, 32, 2, 0, 1, 0,  // Purple Test at bottom right\n            // TODO : Add more to test negative scaling.\n        ]);\n\n        this.setupVAO();\n\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n\n        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;\n        this.gl.uniform1f(uWorldXLoc, 2 / CONFIG.GAME_SCREEN_X);\n\n        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;\n        this.gl.uniform1f(uWorldYLoc, 2 / -CONFIG.GAME_SCREEN_Y);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning \"use this buffer\" for the following operations)\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, RECTANGLE_MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer\n        this.setupAttribute(0, CONFIG.ATTRIBUTES.POSITION_SIZE, 8, 0);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning \"use this buffer for the following operations\")\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates\n        this.setupAttribute(1, CONFIG.ATTRIBUTES.OFFSET_SIZE, 28, 0, 1);\n        this.setupAttribute(2, CONFIG.ATTRIBUTES.SCALE_SIZE, 28, 8, 1);\n        this.setupAttribute(3, CONFIG.ATTRIBUTES.SCALE_SIZE, 28, 12, 1);\n        this.setupAttribute(4, CONFIG.ATTRIBUTES.COLOR_SIZE, 28, 16, 1);\n\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n\n        // Update the buffer with the new transform data and draw the sprites\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 3); // Draw the model of 6 vertex that form 2 triangles, 3 times\n\n    }\n\n}\n\n",
    "felix.20241113233458.1": "@others\n"
  }
}